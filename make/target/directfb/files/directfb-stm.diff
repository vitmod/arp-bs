Remove the test for a non zero mmio size when returning the
FB fix accelerator field, as the ST FB driver doesn't expose the hardware
registers to usersapce.

Signed off by: Stephen Gallimore <Stephen.Gallimore@st.com>

Index: DirectFB-1.0.1/systems/fbdev/fbdev.c
===================================================================
--- DirectFB-1.0.1.orig/systems/fbdev/fbdev.c	2007-08-19 22:52:06.000000000 +0100
+++ DirectFB-1.0.1/systems/fbdev/fbdev.c	2007-08-30 13:50:34.000000000 +0100
@@ -821,9 +821,7 @@
      if (!strcmp( dfb_fbdev->shared->fix.id, "MATROX DH" ))
           return FB_ACCEL_MATROX_MGAG400;
 #endif
-     if (dfb_fbdev->shared->fix.mmio_len > 0)
-          return dfb_fbdev->shared->fix.accel;
-     return -1;
+     return dfb_fbdev->shared->fix.accel;
 }
 
 static VideoMode *
Use the libtool .la for freetype instead of the old style library specification.

Signed off by Stephen Gallimore <stephen.gallimore@st.com>

Index: DirectFB-1.0.1/configure.in
===================================================================
--- DirectFB-1.0.1.orig/configure.in	2007-08-26 20:41:00.000000000 +0100
+++ DirectFB-1.0.1/configure.in	2007-08-30 13:51:01.000000000 +0100
@@ -802,7 +802,7 @@
     else
       FREETYPE=yes
       FREETYPE_CFLAGS=`$FREETYPE_CONFIG --cflags`
-      FREETYPE_LIBS=`$FREETYPE_CONFIG --libs`
+      FREETYPE_LIBS=`$FREETYPE_CONFIG --libtool`
     fi
   fi
 fi
This patch fixes the following issue:

If DSBLIT_SRC_PREMULTCOLOR is specified, but no other modulation flags are
present, then the color alpha state is not set in the SW rendering pipeline
resulting in the pixel RGB being multiplied by 0 instead of the color alpha. 

Signed of by: Stephen Gallimore <Stephen.Gallimore@st.com>

Index: DirectFB-1.0.1/src/gfx/generic/generic.c
===================================================================
--- DirectFB-1.0.1.orig/src/gfx/generic/generic.c
+++ DirectFB-1.0.1/src/gfx/generic/generic.c
@@ -7070,8 +7070,10 @@ bool gAcquire( CardState *state, DFBAcce
                          }
 
                          /* Premultiply color alpha? */
-                         if (state->blittingflags & DSBLIT_SRC_PREMULTCOLOR)
+                         if (state->blittingflags & DSBLIT_SRC_PREMULTCOLOR) {
+                              gfxs->Cacc.RGB.a = color.a + 1;
                               *funcs++ = Dacc_premultiply_color_alpha;
+                         }
 
                          /* modulate the source if requested */
                          if (Dacc_modulation[modulation & 0x7]) {
Backport additional TV standards from the current GIT tree head and
add NTSC-443.

Signed off by: Stephen Gallimore <Stephen.Gallimore@st.com>

Index: DirectFB-1.0.1/include/directfb.h
===================================================================
--- DirectFB-1.0.1.orig/include/directfb.h
+++ DirectFB-1.0.1/include/directfb.h
@@ -2058,7 +2058,16 @@ typedef enum {
      DSETV_PAL            = 0x00000001, /* PAL */
      DSETV_NTSC           = 0x00000002, /* NTSC */
      DSETV_SECAM          = 0x00000004, /* SECAM */
-     DSETV_PAL_60         = 0x00000008  /* PAL-60 */
+     DSETV_PAL_60         = 0x00000008, /* PAL-60 */
+     DSETV_PAL_BG         = 0x00000010, /* PAL BG support (specific) */
+     DSETV_PAL_I          = 0x00000020, /* PAL I support (specific) */
+     DSETV_PAL_M          = 0x00000040, /* PAL M support (specific) */
+     DSETV_PAL_N          = 0x00000080, /* PAL N support (specific) */
+     DSETV_PAL_NC         = 0x00000100, /* PAL NC support (specific) */
+     DSETV_NTSC_M_JPN     = 0x00000200, /* NTSC_JPN support */
+     DSETV_NTSC_443       = 0x00000400, /* NTSC with 4.43MHz colour carrier */
+     DSETV_DIGITAL        = 0x00000800, /* TV standards from the digital domain.  specify resolution, scantype, frequency.*/
+     DSETV_ALL            = 0x00000FFF  /* All TV Standards*/
 } DFBScreenEncoderTVStandards;
 
 /*
Prevent primarySetRegion from changing the framebuffer var when none of
the relevent properties have been changed.

Signed off by: Stephen Gallimore <stephen.gallimore@st.com>
Index: DirectFB-1.0.1/systems/fbdev/fbdev.c
===================================================================
--- DirectFB-1.0.1.orig/systems/fbdev/fbdev.c
+++ DirectFB-1.0.1/systems/fbdev/fbdev.c
@@ -1321,6 +1321,9 @@ primarySetRegion( CoreLayer             
 
      switch (updated & (CLRCF_BUFFERMODE | CLRCF_FORMAT | CLRCF_HEIGHT |
                         CLRCF_SURFACE | CLRCF_WIDTH |  CLRCF_SOURCE)) {
+     case CLRCF_NONE:
+          /* No Flags - Clear pass through */
+          break;
      case CLRCF_SOURCE:
           if (config->source.w == shared->current_mode.xres &&
               config->source.h == shared->current_mode.yres) {
This patch extends display layer configuration and the DirectFB
configuration system to support selecting display modes based
on their scan mode (interlaced/progressive) and vertical refresh
rate. Such selection is implemented for the primary layer in
the fbdev system. This is now sufficient to select any VESA
or CEA-861-C DTV mode given suitable framebuffer driver support
and entries in /etc/fb.modes. 

The current DirectFB semantics for mode selection have been
maintained, unless a more selective mode is specified
either in user configuration or programatically via 
IDirectFBDisplayLayer::SetConfiguration. This includes
the current behaviour of IDirectFB::SetVideoMode and
IDirectFB::CreateSurface for the primary surface.

The "mode=" configuration on the command line and directfbrc files
has been extended, in a compatible manner, to allow the default
mode to specify a refresh rate and scan mode. The commandline
help "--dfb:help" has been updated to show the new syntax.

Signed off by: Stephen Gallimore <stephen.gallimore@st.com>
Index: DirectFB-1.0.1/include/directfb.h
===================================================================
--- DirectFB-1.0.1.orig/include/directfb.h
+++ DirectFB-1.0.1/include/directfb.h
@@ -1801,6 +1801,15 @@ typedef enum {
 } DFBDisplayLayerBackgroundMode;
 
 /*
+ * Layer scan mode, which translates to display mode's scan type.
+ */
+typedef enum {
+  DLSM_DONTCARE               = 0,
+  DLSM_PROGRESSIVE,
+  DLSM_INTERLACED
+} DFBDisplayLayerScanMode;
+
+/*
  * Layer configuration flags
  */
 typedef enum {
@@ -1813,8 +1822,10 @@ typedef enum {
      DLCONF_OPTIONS           = 0x00000010,
      DLCONF_SOURCE            = 0x00000020,
      DLCONF_SURFACE_CAPS      = 0x00000040,
+     DLCONF_SCANMODE          = 0x00000080,
+     DLCONF_REFRESHRATE       = 0x00000100,
 
-     DLCONF_ALL               = 0x0000007F
+     DLCONF_ALL               = 0x000001FF
 } DFBDisplayLayerConfigFlags;
 
 /*
@@ -1832,6 +1843,9 @@ typedef struct {
 
      DFBSurfaceCapabilities        surface_caps;  /* Choose surface capabilities, available:
                                                      INTERLACED, SEPARATED, PREMULTIPLIED. */
+
+     DFBDisplayLayerScanMode       scanmode;      /* Choose progressive or interlaced display mode */
+     int                           refreshrate;   /* Display refresh rate in 1/100th Hz */
 } DFBDisplayLayerConfig;
 
 /*
Index: DirectFB-1.0.1/src/core/layer_context.c
===================================================================
--- DirectFB-1.0.1.orig/src/core/layer_context.c
+++ DirectFB-1.0.1/src/core/layer_context.c
@@ -541,6 +541,12 @@ dfb_layer_context_test_configuration( Co
 
                if (failed & CLRCF_SURFACE_CAPS)
                     flags |= DLCONF_SURFACE_CAPS;
+
+               if (failed & CLRCF_SCANMODE)
+                    flags |= DLCONF_SCANMODE;
+
+               if (failed & CLRCF_REFRESHRATE)
+                    flags |= DLCONF_REFRESHRATE;
           }
 
           *ret_failed = flags;
@@ -694,6 +700,12 @@ dfb_layer_context_set_configuration( Cor
      if (config->flags & DLCONF_SURFACE_CAPS)
           context->config.surface_caps = config->surface_caps;
 
+     if (config->flags & DLCONF_SCANMODE)
+          context->config.scanmode = config->scanmode;
+
+     if (config->flags & DLCONF_REFRESHRATE)
+          context->config.refreshrate = config->refreshrate;
+
      /* Update the window stack. */
      if (context->stack) {
           CoreWindowStack *stack = context->stack;
@@ -1409,6 +1421,18 @@ build_updated_config( CoreLayer         
           ret_config->surface_caps = update->surface_caps;
      }
 
+     /* Change scan mode. */
+     if (update->flags & DLCONF_SCANMODE) {
+          flags |= CLRCF_SCANMODE;
+          ret_config->scanmode = update->scanmode;
+     }
+
+     /* Change refresh rate. */
+     if (update->flags & DLCONF_REFRESHRATE) {
+          flags |= CLRCF_REFRESHRATE;
+          ret_config->refreshrate = update->refreshrate;
+     }
+
      /* Return translated flags. */
      if (ret_flags)
           *ret_flags = flags;
Index: DirectFB-1.0.1/src/core/layers.h
===================================================================
--- DirectFB-1.0.1.orig/src/core/layers.h
+++ DirectFB-1.0.1/src/core/layers.h
@@ -59,6 +59,10 @@ struct __DFB_CoreLayerRegionConfig {
      DFBRegion                 *clips;            /* clip regions */
      int                        num_clips;        /* number of clip regions */
      DFBBoolean                 positive;         /* show or cut out regions */
+
+     DFBDisplayLayerScanMode    scanmode;         /* display scan mode (progressive/interlaced)
+                                                     note this may be different to the surface caps */
+     int                        refreshrate;      /* display refresh frequency, 1/100th Hz */
 };
 
 typedef enum {
@@ -85,10 +89,13 @@ typedef enum {
 
      CLRCF_PARITY       = 0x00100000,
 
+     CLRCF_SCANMODE     = 0x01000000,
+     CLRCF_REFRESHRATE  = 0x02000000,
+
      CLRCF_SURFACE      = 0x10000000,
      CLRCF_PALETTE      = 0x20000000,
 
-     CLRCF_ALL          = 0x3013377F
+     CLRCF_ALL          = 0x3313377F
 } CoreLayerRegionConfigFlags;
 
 typedef struct {
Index: DirectFB-1.0.1/src/core/layer_region.c
===================================================================
--- DirectFB-1.0.1.orig/src/core/layer_region.c
+++ DirectFB-1.0.1/src/core/layer_region.c
@@ -607,6 +607,12 @@ dfb_layer_region_set_configuration( Core
           if (flags & CLRCF_BUFFERMODE)
                new_config.buffermode = config->buffermode;
 
+          if (flags & CLRCF_SCANMODE)
+               new_config.scanmode = config->scanmode;
+
+          if (flags & CLRCF_REFRESHRATE)
+               new_config.refreshrate = config->refreshrate;
+
           if (flags & CLRCF_OPTIONS)
                new_config.options = config->options;
 
Index: DirectFB-1.0.1/systems/fbdev/fbdev.c
===================================================================
--- DirectFB-1.0.1.orig/systems/fbdev/fbdev.c
+++ DirectFB-1.0.1/systems/fbdev/fbdev.c
@@ -232,6 +232,7 @@ static DFBResult dfb_fbdev_set_mode( Cor
                                      CoreLayerRegionConfig *config );
 static void      dfb_fbdev_var_to_mode( struct fb_var_screeninfo *var,
                                         VideoMode                *mode );
+static int       dfb_fbdev_mode_refresh_rate( VideoMode *mode );
 
 /******************************************************************************/
 
@@ -1098,10 +1099,14 @@ primaryInitLayer( CoreLayer             
 
      /* fill out the default configuration */
      config->flags      = DLCONF_WIDTH       | DLCONF_HEIGHT |
-                          DLCONF_PIXELFORMAT | DLCONF_BUFFERMODE;
+                          DLCONF_PIXELFORMAT | DLCONF_BUFFERMODE |
+                          DLCONF_SCANMODE    | DLCONF_REFRESHRATE;
      config->buffermode = DLBM_FRONTONLY;
      config->width      = default_mode->xres;
      config->height     = default_mode->yres;
+     /* for backwards compatibility, match any scan mode and refreshrate by default */
+     config->scanmode   = DLSM_DONTCARE;
+     config->refreshrate= 0;
      
      tmp.format     = DSPF_RGB16;
      tmp.buffermode = DLBM_FRONTONLY;
@@ -1254,18 +1259,22 @@ primaryTestRegion( CoreLayer            
 {
      VideoMode                  *videomode = NULL;
      CoreLayerRegionConfigFlags  fail = 0;
+     int wantlaced = (config->scanmode==DLSM_INTERLACED)?1:0;
 
      videomode = dfb_fbdev->shared->modes;
      while (videomode) {
+          int refreshrate = dfb_fbdev_mode_refresh_rate(videomode);
           if (videomode->xres == config->source.w  &&
-              videomode->yres == config->source.h)
+              videomode->yres == config->source.h  &&
+                (config->refreshrate == 0 || refreshrate == config->refreshrate) &&
+                (config->scanmode == DLSM_DONTCARE || videomode->laced == wantlaced))
                break;
 
           videomode = videomode->next;
      }
 
      if (!videomode || dfb_fbdev_set_mode( NULL, videomode, config ))
-          fail |= CLRCF_WIDTH | CLRCF_HEIGHT | CLRCF_FORMAT | CLRCF_BUFFERMODE;
+          fail |= CLRCF_WIDTH | CLRCF_HEIGHT | CLRCF_FORMAT | CLRCF_BUFFERMODE | CLRCF_SCANMODE | CLRCF_REFRESHRATE;
 
      if (config->options)
           fail |= CLRCF_OPTIONS;
@@ -1303,11 +1312,15 @@ primarySetRegion( CoreLayer             
      VideoMode *videomode;
      VideoMode *highest = NULL;
      FBDevShared *shared = dfb_fbdev->shared;
+     int wantlaced = (config->scanmode==DLSM_INTERLACED)?1:0;
 
      videomode = shared->modes;
      while (videomode) {
+          int refreshrate = dfb_fbdev_mode_refresh_rate(videomode);
           if (videomode->xres == config->source.w  &&
-              videomode->yres == config->source.h)
+              videomode->yres == config->source.h  &&
+              (config->refreshrate == 0 || refreshrate == config->refreshrate) &&
+              (config->scanmode == DLSM_DONTCARE || videomode->laced == wantlaced))
           {
                if (!highest || highest->priority < videomode->priority)
                     highest = videomode;
@@ -1320,7 +1333,8 @@ primarySetRegion( CoreLayer             
           return DFB_UNSUPPORTED;
 
      switch (updated & (CLRCF_BUFFERMODE | CLRCF_FORMAT | CLRCF_HEIGHT |
-                        CLRCF_SURFACE | CLRCF_WIDTH |  CLRCF_SOURCE)) {
+                        CLRCF_SURFACE | CLRCF_WIDTH |  CLRCF_SOURCE |
+                        CLRCF_SCANMODE | CLRCF_REFRESHRATE)) {
      case CLRCF_NONE:
           /* No Flags - Clear pass through */
           break;
@@ -1506,6 +1520,19 @@ static void dfb_fbdev_var_to_mode( struc
      mode->doubled       = (var->vmode & FB_VMODE_DOUBLE) ? 1 : 0;
 }
 
+static int dfb_fbdev_mode_refresh_rate( VideoMode *mode)
+{
+     unsigned int htotal = mode->left_margin+mode->xres+mode->right_margin+mode->hsync_len;
+     unsigned int vtotal = mode->upper_margin+mode->yres+mode->lower_margin+mode->vsync_len;
+     double vrate;
+
+     if (!mode->laced)
+        vtotal *= 2;
+
+     vrate = (((1E12/mode->pixclock)/htotal)/vtotal)*2*100;
+     return (int)vrate;
+}
+
 static int dfb_fbdev_compatible_format( struct fb_var_screeninfo *var,
                                         int al, int rl, int gl, int bl,
                                         int ao, int ro, int go, int bo )
Index: DirectFB-1.0.1/src/directfb.c
===================================================================
--- DirectFB-1.0.1.orig/src/directfb.c
+++ DirectFB-1.0.1/src/directfb.c
@@ -305,9 +305,11 @@ apply_configuration( IDirectFB        *d
           layer_config.buffermode = dfb_config->buffer_mode;
      
      if (dfb_config->mode.width > 0 && dfb_config->mode.height > 0) {
-          layer_config.flags |= DLCONF_WIDTH | DLCONF_HEIGHT;
-          layer_config.width  = dfb_config->mode.width;
-          layer_config.height = dfb_config->mode.height;
+          layer_config.flags      |= DLCONF_WIDTH | DLCONF_HEIGHT | DLCONF_SCANMODE | DLCONF_REFRESHRATE;
+          layer_config.width       = dfb_config->mode.width;
+          layer_config.height      = dfb_config->mode.height;
+          layer_config.scanmode    = dfb_config->mode.scanmode;
+          layer_config.refreshrate = dfb_config->mode.refreshrate;
      }
 
      if (dfb_config->mode.format != DSPF_UNKNOWN) {
@@ -325,13 +327,13 @@ apply_configuration( IDirectFB        *d
      }
 
      if (dfb_layer_context_test_configuration( context, &layer_config, &fail )) {
-          if (fail & (DLCONF_WIDTH | DLCONF_HEIGHT)) {
+          if (fail & (DLCONF_WIDTH | DLCONF_HEIGHT | DLCONF_SCANMODE | DLCONF_REFRESHRATE)) {
                D_ERROR( "DirectFB/DirectFBCreate: "
                         "Setting desktop resolution to %dx%d failed!\n"
                         "     -> Using default resolution.\n",
                         layer_config.width, layer_config.height );
                
-               layer_config.flags &= ~(DLCONF_WIDTH | DLCONF_HEIGHT);
+               layer_config.flags &= ~(DLCONF_WIDTH | DLCONF_HEIGHT | DLCONF_SCANMODE | DLCONF_REFRESHRATE);
           }
 
           if (fail & DLCONF_PIXELFORMAT) { 
Index: DirectFB-1.0.1/src/idirectfb.c
===================================================================
--- DirectFB-1.0.1.orig/src/idirectfb.c
+++ DirectFB-1.0.1/src/idirectfb.c
@@ -367,11 +367,16 @@ IDirectFB_SetVideoMode( IDirectFB    *th
                DFBResult ret;
                DFBDisplayLayerConfig config;
 
-               config.flags       = DLCONF_WIDTH | DLCONF_HEIGHT |
+               config.flags       = DLCONF_WIDTH | DLCONF_HEIGHT | DLCONF_SCANMODE | DLCONF_REFRESHRATE |
                                     DLCONF_PIXELFORMAT;
                config.width       = width;
                config.height      = height;
                config.pixelformat = format;
+               /*
+                * Preserve API behaviour, match display mode only on width and height
+                */
+               config.scanmode    = DLSM_DONTCARE;
+               config.refreshrate = 0;
 
                ret = dfb_layer_context_set_configuration( data->primary.context,
                                                           &config );
@@ -635,7 +640,7 @@ IDirectFB_CreateSurface( IDirectFB      
                     CoreLayerContext *context = data->primary.context;
 
                     config.flags |= DLCONF_BUFFERMODE | DLCONF_PIXELFORMAT |
-                                    DLCONF_WIDTH | DLCONF_HEIGHT;
+                                    DLCONF_WIDTH | DLCONF_HEIGHT | DLCONF_SCANMODE | DLCONF_REFRESHRATE;
 
                     /* Source compatibility with older programs */
                     if ((caps & DSCAPS_FLIPPING) == DSCAPS_FLIPPING)
@@ -662,6 +667,8 @@ IDirectFB_CreateSurface( IDirectFB      
                     config.pixelformat = format;
                     config.width       = width;
                     config.height      = height;
+                    config.scanmode    = dfb_config->mode.scanmode;
+                    config.refreshrate = dfb_config->mode.refreshrate;
 
                     ret = dfb_layer_context_set_configuration( context, &config );
                     if (ret) {
Index: DirectFB-1.0.1/src/misc/conf.c
===================================================================
--- DirectFB-1.0.1.orig/src/misc/conf.c
+++ DirectFB-1.0.1/src/misc/conf.c
@@ -65,7 +65,11 @@ static const char *config_usage =
      "  system=<system>                Specify the system (FBDev, SDL, etc.)\n"
      "  fbdev=<device>                 Open <device> instead of /dev/fb0\n"
      "  busid=<id>                     Specify the bus location of the graphics card (default 1:0:0)\n"
-     "  mode=<width>x<height>          Set the default resolution\n"
+     "  mode=<width>x<height>[-<vrefresh>[(i|p)]]\n"
+     "                                 Set the default resolution, vrefresh can be in\n"
+     "                                 Hz or 1/100ths Hz. E.g. :\n"
+     "                                 1280x720-60p (60Hz progressive) or\n"
+     "                                 1920x1080-5994i (59.94Hz interlaced)\n"
      "  scaled=<width>x<height>        Scale the window to this size for 'force-windowed' apps\n"
      "  depth=<pixeldepth>             Set the default pixel depth\n"
      "  pixelformat=<pixelformat>      Set the default pixel format\n"
@@ -497,11 +501,31 @@ DFBResult dfb_config_set( const char *na
      } else
      if (strcmp (name, "mode" ) == 0) {
           if (value) {
-               int width, height;
+               int width, height, refreshrate, count;
+               char laced;
 
-               if (sscanf( value, "%dx%d", &width, &height ) < 2) {
-                    D_ERROR("DirectFB/Config 'mode': Could not parse mode!\n");
-                    return DFB_INVARG;
+               count = sscanf( value, "%dx%d-%d%c", &width, &height,&refreshrate,&laced);
+               switch  (count) {
+                    case 2:
+                         dfb_config->mode.refreshrate = 0;
+                         dfb_config->mode.scanmode = DLSM_DONTCARE;
+                         break;
+                    case 3:
+                         dfb_config->mode.refreshrate = refreshrate<300?refreshrate*100:refreshrate;
+                         dfb_config->mode.scanmode = DLSM_DONTCARE;
+                         break;
+                    case 4:
+                         if(laced != 'i' && laced != 'p') {
+                              D_ERROR("DirectFB/Config 'mode': Could not parse mode!\n");
+                              return DFB_INVARG;
+                         }
+
+                         dfb_config->mode.refreshrate = refreshrate<300?refreshrate*100:refreshrate;
+                         dfb_config->mode.scanmode = (laced == 'i')?DLSM_INTERLACED:DLSM_PROGRESSIVE;
+                         break;
+                    default:
+                         D_ERROR("DirectFB/Config 'mode': Could not parse mode!\n");
+                         return DFB_INVARG;
                }
 
                dfb_config->mode.width  = width;
Index: DirectFB-1.0.1/src/misc/conf.h
===================================================================
--- DirectFB-1.0.1.orig/src/misc/conf.h
+++ DirectFB-1.0.1/src/misc/conf.h
@@ -98,10 +98,12 @@ typedef struct
                                                      windows */
 
      struct {
-          int                   width;            /* primary layer width */
-          int                   height;           /* primary layer height */
-          int                   depth;            /* primary layer depth */
-          DFBSurfacePixelFormat format;           /* primary layer format */
+          int                     width;          /* primary layer width */
+          int                     height;         /* primary layer height */
+          int                     depth;          /* primary layer depth */
+          DFBSurfacePixelFormat   format;         /* primary layer format */
+          DFBDisplayLayerScanMode scanmode;       /* primary layer display scan mode */
+          int                     refreshrate;    /* primary layer display refresh rate */
      } mode;
 
      struct {
Add support for the ARGB8565 color format to DirectFB.

Signed of by: Andre' Draszik <andre.draszik@st.com>

Index: DirectFB-1.0.1/include/directfb.h
===================================================================
--- DirectFB-1.0.1.orig/include/directfb.h	2007-09-24 14:34:21.356348069 +0100
+++ DirectFB-1.0.1/include/directfb.h	2007-09-24 14:34:25.068618276 +0100
@@ -1014,12 +1014,15 @@ typedef enum {
      DSPF_RGB444    = DFB_SURFACE_PIXELFORMAT( 26, 12, 0, 0, 0, 2, 0, 0, 0, 0, 0 ),
 
      /* 16 bit   RGB (2 byte, nothing @15, red 5@10, green 5@5, blue 5@0) */
-     DSPF_RGB555    = DFB_SURFACE_PIXELFORMAT( 27, 15, 0, 0, 0, 2, 0, 0, 0, 0, 0 )
+     DSPF_RGB555    = DFB_SURFACE_PIXELFORMAT( 27, 15, 0, 0, 0, 2, 0, 0, 0, 0, 0 ),
+
+     /* 16 bit  ARGB (3 byte, alpha 8@16, red 5@11, green 6@5, blue 5@0) */
+     DSPF_ARGB8565  = DFB_SURFACE_PIXELFORMAT( 28, 16, 8, 1, 0, 3, 0, 0, 0, 0, 0 )
 
 } DFBSurfacePixelFormat;
 
 /* Number of pixelformats defined */
-#define DFB_NUM_PIXELFORMATS            28
+#define DFB_NUM_PIXELFORMATS            29
 
 /* These macros extract information about the pixel format. */
 #define DFB_PIXELFORMAT_INDEX(fmt)      (((fmt) & 0x0000007F)      )
Index: DirectFB-1.0.1/interfaces/IDirectFBFont/idirectfbfont_default.c
===================================================================
--- DirectFB-1.0.1.orig/interfaces/IDirectFBFont/idirectfbfont_default.c	2007-09-24 14:34:21.380349814 +0100
+++ DirectFB-1.0.1/interfaces/IDirectFBFont/idirectfbfont_default.c	2007-09-24 14:34:25.068618276 +0100
@@ -110,6 +110,7 @@ Construct( IDirectFBFont      *thiz,
 
      D_ASSERT( font->pixel_format == DSPF_ARGB ||
                font->pixel_format == DSPF_AiRGB ||
+               font->pixel_format == DSPF_ARGB8565 ||
                font->pixel_format == DSPF_ARGB4444 ||
                font->pixel_format == DSPF_ARGB2554 ||
                font->pixel_format == DSPF_ARGB1555 ||
@@ -233,6 +234,20 @@ Construct( IDirectFBFont      *thiz,
                     for (n=0; n<font_desc.width; n++)
                          dst32[n] = ((pixels[n] ^ 0xFF) << 24) | 0xFFFFFF;
                     break;
+               case DSPF_ARGB8565:
+                    for (n = 0, j = -1; n < font_desc.width; ++n) {
+                         u32 d = (pixels[n] << 16) | 0xFFFF;
+#ifdef WORDS_BIGENDIAN
+                         dst8[++j] = (d >> 16) & 0xff;
+                         dst8[++j] = (d >>  8) & 0xff;
+                         dst8[++j] = (d >>  0) & 0xff;
+#else
+                         dst8[++j] = (d >>  0) & 0xff;
+                         dst8[++j] = (d >>  8) & 0xff;
+                         dst8[++j] = (d >> 16) & 0xff;
+#endif
+                    }
+                    break;
                case DSPF_ARGB4444:
                     for (n=0; n<font_desc.width; n++)
                          dst16[n] = (pixels[n] << 8) | 0xFFF;
Index: DirectFB-1.0.1/interfaces/IDirectFBFont/idirectfbfont_ft2.c
===================================================================
--- DirectFB-1.0.1.orig/interfaces/IDirectFBFont/idirectfbfont_ft2.c	2007-09-24 14:34:21.396350974 +0100
+++ DirectFB-1.0.1/interfaces/IDirectFBFont/idirectfbfont_ft2.c	2007-09-24 14:34:25.068618276 +0100
@@ -325,6 +325,20 @@ render_glyph( CoreFont      *thiz,
                               for (i=0; i<info->width; i++)
                                    dst32[i] = ((src[i] ^ 0xFF) << 24) | 0xFFFFFF;
                               break;
+                         case DSPF_ARGB8565:
+                              for (i = 0, j = -1; i < info->width; ++i) {
+                                   u32 d = (src[i] << 16) | 0xFFFF;
+#ifdef WORDS_BIGENDIAN
+                                   dst8[++j] = (d >> 16) & 0xff;
+                                   dst8[++j] = (d >>  8) & 0xff;
+                                   dst8[++j] = (d >>  0) & 0xff;
+#else
+                                   dst8[++j] = (d >>  0) & 0xff;
+                                   dst8[++j] = (d >>  8) & 0xff;
+                                   dst8[++j] = (d >> 16) & 0xff;
+#endif
+                              }
+                              break;
                          case DSPF_ARGB4444:
                               for (i=0; i<info->width; i++)
                                    dst16[i] = (src[i] << 8) | 0xFFF;
@@ -382,6 +396,21 @@ render_glyph( CoreFont      *thiz,
                                    dst32[i] = (((src[i>>3] & (1<<(7-(i%8)))) ?
                                                 0x00 : 0xFF) << 24) | 0xFFFFFF;
                               break;
+                      case DSPF_ARGB8565:
+                              for (i = 0, j = -1; i < info->width; ++i) {
+                                   u32 d = (((src[i>>3] & (1<<(7-(i%8)))) ?
+                                             0xff : 0x00) << 16) | 0xffff;
+#ifdef WORDS_BIGENDIAN
+                                   dst8[++j] = (d >> 16) & 0xff;
+                                   dst8[++j] = (d >>  8) & 0xff;
+                                   dst8[++j] = (d >>  0) & 0xff;
+#else
+                                   dst8[++j] = (d >>  0) & 0xff;
+                                   dst8[++j] = (d >>  8) & 0xff;
+                                   dst8[++j] = (d >> 16) & 0xff;
+#endif
+                           }
+                           break;
                          case DSPF_ARGB4444:
                               for (i=0; i<info->width; i++)
                                    dst16[i] = (((src[i>>3] & (1<<(7-(i%8)))) ?
@@ -833,6 +862,7 @@ Construct( IDirectFBFont      *thiz,
 
      D_ASSERT( font->pixel_format == DSPF_ARGB ||
                font->pixel_format == DSPF_AiRGB ||
+               font->pixel_format == DSPF_ARGB8565 ||
                font->pixel_format == DSPF_ARGB4444 ||
                font->pixel_format == DSPF_ARGB2554 ||
                font->pixel_format == DSPF_ARGB1555 ||
Index: DirectFB-1.0.1/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_v4l.c
===================================================================
--- DirectFB-1.0.1.orig/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_v4l.c	2007-09-24 14:34:21.420352721 +0100
+++ DirectFB-1.0.1/interfaces/IDirectFBVideoProvider/idirectfbvideoprovider_v4l.c	2007-09-24 14:34:25.072618571 +0100
@@ -904,6 +904,7 @@ static DFBResult v4l_to_surface_overlay(
                palette = VIDEO_PALETTE_RGB555;
                break;
           case DSPF_RGB16:
+          case DSPF_ARGB8565:
                bpp = 16;
                palette = VIDEO_PALETTE_RGB565;
                break;
@@ -1030,6 +1031,7 @@ static DFBResult v4l_to_surface_grab( Co
                palette = VIDEO_PALETTE_RGB555;
                break;
           case DSPF_RGB16:
+          case DSPF_ARGB8565:
                palette = VIDEO_PALETTE_RGB565;
                break;
           case DSPF_RGB24:
@@ -1354,6 +1356,7 @@ static DFBResult v4l2_playto(CoreSurface
                palette = V4L2_PIX_FMT_RGB555;
                break;
           case DSPF_RGB16:
+          case DSPF_ARGB8565:
                palette = V4L2_PIX_FMT_RGB565;
                break;
           case DSPF_RGB24:
Index: DirectFB-1.0.1/src/core/surfaces.c
===================================================================
--- DirectFB-1.0.1.orig/src/core/surfaces.c	2007-09-24 14:34:21.448354759 +0100
+++ DirectFB-1.0.1/src/core/surfaces.c	2007-09-24 14:34:25.072618571 +0100
@@ -1094,6 +1094,7 @@ DFBResult dfb_surface_init ( CoreDFB    
           case DSPF_A8:
           case DSPF_ALUT44:
           case DSPF_ARGB:
+          case DSPF_ARGB8565:
           case DSPF_ARGB1666:
           case DSPF_ARGB6666:
           case DSPF_ARGB1555:
@@ -1233,6 +1234,7 @@ DFBResult dfb_surface_dump( CoreDFB     
                break;
 
           case DSPF_ARGB:
+          case DSPF_ARGB8565:
           case DSPF_ARGB1555:
           case DSPF_ARGB2554:
           case DSPF_ARGB4444:
@@ -1446,6 +1448,25 @@ DFBResult dfb_surface_dump( CoreDFB     
                          }
                     }
                     break;
+               case DSPF_ARGB8565:
+                    for (n = 0, n3 = 0; n<surface->width; n++, n3 += 3) {
+#ifdef WORDS_BIGENDIAN
+                         buf_g[n] = data8[n3+0];
+
+                         buf_p[n3+0] = (data8[n3+1] & 0xF8);
+                         buf_p[n3+1] = ((data8[n3+1] & 0x07) << 5)
+                                       | ((data8[n3+2] & 0xe0) >> 3);
+                         buf_p[n3+2] = (data8[n3+2] & 0x1F) << 3;
+#else
+                         buf_g[n] = data8[n3+2];
+
+                         buf_p[n3+0] = (data8[n3+1] & 0xF8);
+                         buf_p[n3+1] = ((data8[n3+1] & 0x07) << 5)
+                                       | ((data8[n3+0] & 0xe0) >> 3);
+                         buf_p[n3+2] = (data8[n3+0] & 0x1F) << 3;
+#endif
+                    }
+                    break;
                case DSPF_ARGB4444:
                     for (n=0, n3=0; n<surface->width; n++, n3+=3) {
                          buf_p[n3+0] = (data16[n] & 0x0F00) >> 4;
Index: DirectFB-1.0.1/src/gfx/convert.c
===================================================================
--- DirectFB-1.0.1.orig/src/gfx/convert.c	2007-09-24 14:34:21.460355633 +0100
+++ DirectFB-1.0.1/src/gfx/convert.c	2007-09-24 14:34:25.072618571 +0100
@@ -99,6 +99,7 @@ dfb_color_to_pixel( DFBSurfacePixelForma
                pixel = PIXEL_RGB444( r, g, b );
                break;
           case DSPF_RGB16:
+          case DSPF_ARGB8565:
                pixel = PIXEL_RGB16( r, g, b );
                break;
           case DSPF_RGB18:
@@ -173,6 +174,8 @@ dfb_pixel_to_color( DFBSurfacePixelForma
                ret_color->b = EXPAND_4to8( (pixel & 0x000f)       );
                break;
 
+          case DSPF_ARGB8565:
+               ret_color->a = pixel >> 16;
           case DSPF_RGB16:
                ret_color->r = EXPAND_5to8( (pixel & 0xf800) >> 11 );
                ret_color->g = EXPAND_6to8( (pixel & 0x07e0) >>  5 );
@@ -215,6 +218,9 @@ dfb_pixelformat_name( DFBSurfacePixelFor
           case DSPF_RGB555:
                return "RGB555";
 
+          case DSPF_ARGB8565:
+               return "ARGB8565";
+
           case DSPF_RGB16:
                return "RGB16";
 
Index: DirectFB-1.0.1/src/gfx/convert.h
===================================================================
--- DirectFB-1.0.1.orig/src/gfx/convert.h	2007-09-24 14:34:21.476356800 +0100
+++ DirectFB-1.0.1/src/gfx/convert.h	2007-09-24 14:34:25.072618571 +0100
@@ -81,6 +81,9 @@
                                  ((g) << 8)  | \
                                   (b) )
 
+#define PIXEL_ARGB8565(a,r,g,b)( ((a) << 16) | \
+                                 PIXEL_RGB16 (r, g, b) )
+
 #define PIXEL_ARGB1666(a,r,g,b) ( (((a)&0x80) << 11) | \
                                   (((r)&0xFC) << 10) | \
                                   (((g)&0xFC) <<  4) | \
@@ -145,6 +148,9 @@
                                     (((pixel) & 0x03E0) << 1) | \
                                     (((pixel) & 0x001F)) )
 
+#define ARGB1555_TO_ARGB8565(pixel) ( (((pixel) & 0x8000) ? 0x00FF0000 : 0) | \
+                                      ARGB1555_TO_RGB16 (pixel) )
+
 #define ARGB1555_TO_RGB32(pixel)  ( (((pixel) & 0x7C00) << 9) | \
                                     (((pixel) & 0x03E0) << 6) | \
                                     (((pixel) & 0x001F) << 3) )
@@ -182,6 +188,9 @@
                                     (((pixel) & 0x0780) >> 3) | \
                                     (((pixel) & 0x001F) >> 1) )
 
+#define RGB16_TO_ARGB8565(pixel)  ( 0xFF0000 |                  \
+                                    ((pixel) & 0xffff) )
+
 #define RGB16_TO_RGB32(pixel)  ( (((pixel) & 0xF800) << 8) | \
                                  (((pixel) & 0x07E0) << 5) | \
                                  (((pixel) & 0x001F) << 3) )
@@ -199,6 +208,34 @@
                                     (((pixel) & 0x0780) >> 3) | \
                                     (((pixel) & 0x001F) >> 1) )
 
+
+#define ARGB8565_TO_RGB332(pixel)   ( RGB16_TO_RGB332 (pixel) )
+
+#define ARGB8565_TO_ARGB1555(pixel) ( (((pixel) & 0x800000) >> 16) | \
+                                      (((pixel) & 0x00F800) >>  1) | \
+                                      (((pixel) & 0x0007C0) >>  1) | \
+                                      (((pixel) & 0x00001F)) )
+
+#define ARGB8565_TO_ARGB2554(pixel) ( (((pixel) & 0xC00000) >> 16) | \
+                                      (((pixel) & 0x00F800) >>  2) | \
+                                      (((pixel) & 0x0007C0) >>  2) | \
+                                      (((pixel) & 0x00001F) >>  1) )
+
+#define ARGB8565_TO_ARGB4444(pixel) ( (((pixel) & 0xF00000) >> 16) | \
+                                      (((pixel) & 0x00F000) >>  4) | \
+                                      (((pixel) & 0x000780) >>  3) | \
+                                      (((pixel) & 0x00001F) >>  1) )
+
+#define ARGB8565_TO_RGB16(pixel)    ( ((pixel) & 0xffff) )
+
+#define ARGB8565_TO_RGB32(pixel)    ( RGB16_TO_RGB32 (pixel) )
+
+#define ARGB8565_TO_ARGB(pixel)     ( (((pixel) & 0xFF0000) << 8) | \
+                                      (((pixel) & 0x00F800) << 8) | \
+                                      (((pixel) & 0x0007E0) << 5) | \
+                                      (((pixel) & 0x00001F) << 3) )
+
+
 #define RGB18_TO_ARGB(pixel)   ( 0xFF000000 |                \
                                  (((pixel) & 0xFC00) << 10) | \
                                  (((pixel) & 0x3F00) << 4) | \
@@ -227,6 +264,9 @@
                                  (((pixel) & 0x00FC00) >> 5) | \
                                  (((pixel) & 0x0000F8) >> 3) )
 
+#define RGB32_TO_ARGB8565(pixel) ( 0xff0000 | \
+                                   RGB32_TO_RGB16 (pixel) )
+
 #define RGB32_TO_ARGB1555(pixel) ( 0x8000 | \
                                    (((pixel) & 0xF80000) >> 9) | \
                                    (((pixel) & 0x00F800) >> 6) | \
@@ -234,6 +274,11 @@
 
 #define RGB32_TO_ARGB(pixel)   ( 0xFF000000 | (pixel) )
 
+#define ARGB_TO_ARGB8565(pixel)  ( (((pixel) & 0xFF000000) >>  8) | \
+                                   (((pixel) & 0x00F80000) >>  8) | \
+                                   (((pixel) & 0x0000FC00) >>  5) | \
+                                   (((pixel) & 0x000000F8) >>  3) )
+
 
 #define RGB32_TO_RGB555(pixel)  ( (((pixel) & 0xF80000) >> 9) | \
                                     (((pixel) & 0x00F800) >> 6) | \
@@ -381,6 +426,27 @@ dfb_argb_to_argb4444( u32 *src, u16 *dst
 }
 
 static inline void
+dfb_argb_to_argb8565( u32 *src, u8 *dst, int len )
+{
+     int i = -1, j = -1;
+
+     while (++i < len) {
+        register u32 argb = src[i];
+
+        register u32 d = ARGB_TO_ARGB8565( argb );
+#ifdef WORDS_BIGENDIAN
+        dst[++j] = (d >> 16) & 0xff;
+        dst[++j] = (d >>  8) & 0xff;
+        dst[++j] = (d >>  0) & 0xff;
+#else
+        dst[++j] = (d >>  0) & 0xff;
+        dst[++j] = (d >>  8) & 0xff;
+        dst[++j] = (d >> 16) & 0xff;
+#endif
+     }
+}
+
+static inline void
 dfb_argb_to_rgb16( u32 *src, u16 *dst, int len )
 {
      int i;
Index: DirectFB-1.0.1/src/gfx/generic/generic.c
===================================================================
--- DirectFB-1.0.1.orig/src/gfx/generic/generic.c	2007-09-24 14:34:21.508359126 +0100
+++ DirectFB-1.0.1/src/gfx/generic/generic.c	2007-09-24 14:34:25.076618862 +0100
@@ -420,6 +420,27 @@ static void Cop_to_Aop_nv21( GenefxState
      }
 }
 
+static void Cop_to_Aop_argb8565( GenefxState *gfxs )
+{
+     int  w   = gfxs->length + 1;
+     u8  *D   = gfxs->Aop[0];
+     u32  Cop = gfxs->Cop;
+
+     while (--w) {
+#ifdef WORDS_BIGENDIAN
+          D[0] = (Cop >> 16) & 0xff;
+          D[1] = (Cop >>  8) & 0xff;
+          D[2] = (Cop >>  0) & 0xff;
+#else
+          D[0] = (Cop >>  0) & 0xff;
+          D[1] = (Cop >>  8) & 0xff;
+          D[2] = (Cop >> 16) & 0xff;
+#endif
+
+          D += 3;
+     }
+}
+
 static GenefxFunc Cop_to_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Cop_to_Aop_16,      /* DSPF_ARGB1555 */
      Cop_to_Aop_16,      /* DSPF_RGB16 */
@@ -449,6 +470,7 @@ static GenefxFunc Cop_to_Aop_PFI[DFB_NUM
      NULL,               /* DSPF_LUT2 */
      Cop_to_Aop_16,      /* DSPF_RGB444 */
      Cop_to_Aop_16,      /* DSPF_RGB555 */
+     Cop_to_Aop_argb8565 /* DSPF_ARGB8565 */
 };
 
 /********************************* Cop_toK_Aop_PFI ****************************/
@@ -506,6 +528,33 @@ static void Cop_toK_Aop_24( GenefxState 
      }
 }
 
+static void Cop_toK_Aop_argb8565( GenefxState *gfxs )
+{
+     int   w   = gfxs->length + 1;
+     u8   *D   = gfxs->Aop[0];
+     u32   Dkey = gfxs->Dkey;
+     u32   Cop  = gfxs->Cop;
+
+     while (--w) {
+
+#ifdef WORDS_BIGENDIAN
+          if (Dkey == (u32) ((D[1]<<8) | D[2])) {
+               D[0] = (Cop >> 16) & 0xff;
+               D[1] = (Cop >>  8) & 0xff;
+               D[2] = (Cop >>  0) & 0xff;
+          }
+#else
+          if (Dkey == (u32) ((D[1]<<8) | D[0])) {
+               D[0] = (Cop >>  0) & 0xff;
+               D[1] = (Cop >>  8) & 0xff;
+               D[2] = (Cop >> 16) & 0xff;
+          }
+#endif
+
+          D += 3;
+     }
+}
+
 static void Cop_toK_Aop_yuv422( GenefxState *gfxs )
 {
      int    l;
@@ -587,6 +636,7 @@ static GenefxFunc Cop_toK_Aop_PFI[DFB_NU
      NULL,                    /* DSPF_LUT2 */
      Cop_toK_Aop_12,          /* DSPF_RGB444 */
      Cop_toK_Aop_15,          /* DSPF_RGB555 */
+     Cop_toK_Aop_argb8565     /* DSPF_ARGB8565 */
 };
 
 /********************************* Bop_PFI_to_Aop_PFI *************************/
@@ -661,6 +711,7 @@ static GenefxFunc Bop_PFI_to_Aop_PFI[DFB
      NULL,               /* DSPF_LUT2 */
      Bop_16_to_Aop,      /* DSPF_RGB444 */
      Bop_16_to_Aop,      /* DSPF_RGB555 */
+     Bop_24_to_Aop       /* DSPF_ARGB8565 */
 };
 
 /********************************* Bop_PFI_Kto_Aop_PFI ************************/
@@ -695,6 +746,38 @@ static void Bop_rgb18_Kto_Aop( GenefxSta
      }
 }
 
+static void Bop_argb8565_Kto_Aop( GenefxState *gfxs )
+{
+     int    w     = gfxs->length + 1;
+     u8    *D     = gfxs->Aop[0];
+     u8    *S     = gfxs->Bop[0];
+     u32    Skey  = gfxs->Skey;
+     int    Ostep = gfxs->Ostep;
+
+     if (Ostep < 0) {
+          D += (gfxs->length - 1) * 3;
+          S += (gfxs->length - 1) * 3;
+     }
+
+     while (--w) {
+
+#ifdef WORDS_BIGENDIAN
+          u32 s = S[1] << 8 | S[2];
+#else
+          u32 s = S[1] << 8 | S[0];
+#endif
+
+          if (Skey != s) {
+               D[0] = S[0];
+               D[1] = S[1];
+               D[2] = S[2];
+          }
+
+          S += Ostep * 3;
+          D += Ostep * 3;
+     }
+}
+
 static void Bop_rgb24_Kto_Aop( GenefxState *gfxs )
 {
      int    w     = gfxs->length;
@@ -872,6 +955,7 @@ static GenefxFunc Bop_PFI_Kto_Aop_PFI[DF
      NULL,                    /* DSPF_LUT2 */
      Bop_12_Kto_Aop,          /* DSPF_RGB444 */
      Bop_15_Kto_Aop,          /* DSPF_RGB555 */
+     Bop_argb8565_Kto_Aop     /* DSPF_ARGB8565 */
 };
 
 /********************************* Bop_PFI_toK_Aop_PFI ************************/
@@ -914,6 +998,31 @@ static void Bop_rgb24_toK_Aop( GenefxSta
      }
 }
 
+static void Bop_argb8565_toK_Aop( GenefxState *gfxs )
+{
+     int    w     = gfxs->length + 1;
+     u8    *D     = gfxs->Aop[0];
+     u8    *S     = gfxs->Bop[0];
+     u32    Dkey  = gfxs->Dkey;
+
+     while (--w) {
+
+#ifdef WORDS_BIGENDIAN
+          u32 d = D[1] << 8 | D[2];
+#else
+          u32 d = D[1] << 8 | D[0];
+#endif
+          if (Dkey == d) {
+               D[0] = S[0];
+               D[1] = S[1];
+               D[2] = S[2];
+          }
+
+          S +=  3;
+          D +=  3;
+     }
+}
+
 static void Bop_yuv422_toK_Aop( GenefxState *gfxs )
 {
      int    l;
@@ -1009,10 +1118,46 @@ static GenefxFunc Bop_PFI_toK_Aop_PFI[DF
      NULL,                    /* DSPF_LUT2 */
      Bop_12_toK_Aop,          /* DSPF_RGB444 */
      Bop_15_toK_Aop,          /* DSPF_RGB555 */
+     Bop_argb8565_toK_Aop     /* DSPF_ARGB8565 */
 };
 
 /********************************* Bop_PFI_KtoK_Aop_PFI ***********************/
 
+static void Bop_argb8565_KtoK_Aop( GenefxState *gfxs )
+{
+     int  l     = gfxs->length + 1;
+     int  Ostep = gfxs->Ostep;
+     u8  *S     = gfxs->Bop[0];
+     u8  *D     = gfxs->Aop[0];
+     u32  Skey  = gfxs->Skey;
+     u32  Dkey  = gfxs->Dkey;
+
+     if (Ostep < 0) {
+          D += (gfxs->length - 1) * 3;
+          S += (gfxs->length - 1) * 3;
+     }
+
+     while (--l) {
+
+#ifdef WORDS_BIGENDIAN
+          u32 s = S[1] << 8 | S[2];
+          u32 d = D[1] << 8 | D[2];
+#else
+          u32 s = S[1] << 8 | S[0];
+          u32 d = D[1] << 8 | D[0];
+#endif
+
+          if (Skey != s && Dkey == d) {
+               D[0] = S[0];
+               D[1] = S[1];
+               D[2] = S[2];
+          }
+
+          S += Ostep * 3;
+          D += Ostep * 3;
+     }
+}
+
 static GenefxFunc Bop_PFI_KtoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Bop_15_KtoK_Aop,         /* DSPF_ARGB1555 */
      Bop_16_KtoK_Aop,         /* DSPF_RGB16 */
@@ -1042,6 +1187,7 @@ static GenefxFunc Bop_PFI_KtoK_Aop_PFI[D
      NULL,                    /* DSPF_LUT2 */
      Bop_12_KtoK_Aop,         /* DSPF_RGB444 */
      Bop_15_KtoK_Aop,         /* DSPF_RGB555 */
+     Bop_argb8565_KtoK_Aop    /* DSPF_ARGB8565 */
 };
 
 /********************************* Bop_PFI_Sto_Aop_PFI ************************/
@@ -1284,8 +1430,10 @@ static GenefxFunc Bop_PFI_Sto_Aop_PFI[DF
      Bop_24_Sto_Aop,          /* DSPF_ARGB1666 */
      Bop_24_Sto_Aop,          /* DSPF_ARGB6666 */
      Bop_24_Sto_Aop,          /* DSPF_RGB18 */
-     Bop_16_Sto_Aop,          /* DSPF_ARGB4444 */
-     Bop_16_Sto_Aop,          /* DSPF_ARGB1555 */
+     NULL,                    /* DSPF_LUT2 */
+     Bop_16_Sto_Aop,          /* DSPF_ARGB444 */
+     Bop_16_Sto_Aop,          /* DSPF_ARGB555 */
+     Bop_24_Sto_Aop           /* DSPF_ARGB8565 */
 };
 
 /********************************* Bop_PFI_SKto_Aop_PFI ***********************/
@@ -1343,6 +1491,35 @@ static void Bop_rgb24_SKto_Aop( GenefxSt
      }
 }
 
+static void Bop_argb8565_SKto_Aop( GenefxState *gfxs )
+{
+     int    w     = gfxs->length + 1;
+     int    i     = gfxs->Xphase;
+     u8    *D     = gfxs->Aop[0];
+     u8    *S     = gfxs->Bop[0];
+     u32    Skey  = gfxs->Skey;
+     int    SperD = gfxs->SperD;
+
+     while (--w) {
+          int pixelstart = (i >> 16) * 3;
+
+#ifdef WORDS_BIGENDIAN
+          u32 s = S[pixelstart+1] << 8 | S[pixelstart+2];
+#else
+          u32 s = S[pixelstart+1] << 8 | S[pixelstart+0];
+#endif
+
+          if (Skey != s) {
+               D[0] = S[pixelstart+0];
+               D[1] = S[pixelstart+1];
+               D[2] = S[pixelstart+2];
+          }
+
+          D += 3;
+          i += SperD;
+     }
+}
+
 static void Bop_a8_SKto_Aop( GenefxState *gfxs )
 {
      int   w     = gfxs->length;
@@ -1540,10 +1717,40 @@ static GenefxFunc Bop_PFI_SKto_Aop_PFI[D
      NULL,                    /* DSPF_LUT2 */
      Bop_12_SKto_Aop,         /* DSPF_RGB444 */
      Bop_15_SKto_Aop,         /* DSPF_RGB555 */
+     Bop_argb8565_SKto_Aop    /* DSPF_ARGB8565 */
 };
 
 /********************************* Bop_PFI_StoK_Aop_PFI ***********************/
 
+static void Bop_argb8565_StoK_Aop( GenefxState *gfxs )
+{
+     int  l     = gfxs->length + 1;
+     int  i     = gfxs->Xphase;
+     int  SperD = gfxs->SperD;
+     u8  *S     = gfxs->Bop[0];
+     u8  *D     = gfxs->Aop[0];
+     u32  Dkey  = gfxs->Dkey;
+
+     while (--l) {
+          int pixelstart = (i >> 16) * 3;
+
+#ifdef WORDS_BIGENDIAN
+          u32 d = D[1] << 8 | D[2];
+#else
+          u32 d = D[1] << 8 | D[0];
+#endif
+
+          if (Dkey != d) {
+               D[0] = S[pixelstart+0];
+               D[1] = S[pixelstart+1];
+               D[2] = S[pixelstart+2];
+          }
+
+          D += 3;
+          i += SperD;
+     }
+}
+
 static GenefxFunc Bop_PFI_StoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Bop_15_StoK_Aop,         /* DSPF_ARGB1555 */
      Bop_16_StoK_Aop,         /* DSPF_RGB16 */
@@ -1573,10 +1780,43 @@ static GenefxFunc Bop_PFI_StoK_Aop_PFI[D
      NULL,                    /* DSPF_LUT2 */
      Bop_12_StoK_Aop,         /* DSPF_RGB444 */
      Bop_15_StoK_Aop,         /* DSPF_RGB555 */
+     Bop_argb8565_StoK_Aop    /* DSPF_ARGB8565 */
 };
 
 /********************************* Bop_PFI_SKtoK_Aop_PFI **********************/
 
+static void Bop_argb8565_SKtoK_Aop( GenefxState *gfxs )
+{
+     int  l     = gfxs->length + 1;
+     int  i     = gfxs->Xphase;
+     int  SperD = gfxs->SperD;
+     u8  *S     = gfxs->Bop[0];
+     u8  *D     = gfxs->Aop[0];
+     u32  Skey  = gfxs->Skey;
+     u32  Dkey  = gfxs->Dkey;
+
+     while (--l) {
+          int pixelstart = (i >> 16) * 3;
+
+#ifdef WORDS_BIGENDIAN
+          u32 s = S[pixelstart+1] << 8 | S[pixelstart+2];
+          u32 d = D[           1] << 8 | D[           2];
+#else
+          u32 s = S[pixelstart+1] << 8 | S[pixelstart+0];
+          u32 d = D[           1] << 8 | D[           0];
+#endif
+
+          if (Skey != s && Dkey == d) {
+               D[0] = S[pixelstart+0];
+               D[1] = S[pixelstart+1];
+               D[2] = S[pixelstart+2];
+          }
+
+          D += 3;
+          i += SperD;
+     }
+}
+
 static GenefxFunc Bop_PFI_SKtoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Bop_15_SKtoK_Aop,        /* DSPF_ARGB1555 */
      Bop_16_SKtoK_Aop,        /* DSPF_RGB16 */
@@ -1606,6 +1846,7 @@ static GenefxFunc Bop_PFI_SKtoK_Aop_PFI[
      NULL,                    /* DSPF_LUT2 */
      Bop_12_SKtoK_Aop,        /* DSPF_RGB444 */
      Bop_15_SKtoK_Aop,        /* DSPF_RGB555 */
+     Bop_argb8565_SKtoK_Aop   /* DSPF_ARGB8565 */
 };
 
 /********************************* Sop_PFI_Sto_Dacc ***************************/
@@ -1687,6 +1928,42 @@ static void Sop_rgb18_Sto_Dacc( GenefxSt
      }
 }
 
+static void Sop_argb8565_Sto_Dacc( GenefxState *gfxs )
+{
+     int w     = gfxs->length + 1;
+     int i     = gfxs->Xphase;
+     int SperD = gfxs->SperD;
+
+     GenefxAccumulator *D = gfxs->Dacc;
+     u8                *S = gfxs->Sop[0];
+
+     while (--w) {
+          int pixelstart = (i >> 16) * 3;
+
+#ifdef WORDS_BIGENDIAN
+          u8 a = S[pixelstart+0];
+          u8 r = (S[pixelstart+1] & 0xf8) >> 3;
+          u8 g = ((S[pixelstart+1] & 0x07) << 3)
+                 | ((S[pixelstart+2] & 0xe0) >> 5);
+          u8 b = S[pixelstart+2] & 0x1f;
+#else
+          u8 b = S[pixelstart+0] & 0x1f;
+          u8 g = ((S[pixelstart+1] & 0x07) << 3)
+                 | ((S[pixelstart+0] & 0xe0) >> 5);
+          u8 r = (S[pixelstart+1] & 0xf8) >> 3;
+          u8 a = S[pixelstart+2];
+#endif
+
+          D->RGB.a = a;
+          D->RGB.r = EXPAND_5to8 (r);
+          D->RGB.g = EXPAND_6to8 (g);
+          D->RGB.b = EXPAND_5to8 (b);
+
+          D++;
+          i += SperD;
+     }
+}
+
 static void Sop_rgb24_Sto_Dacc( GenefxState *gfxs )
 {
      int w     = gfxs->length;
@@ -2000,6 +2277,7 @@ static GenefxFunc Sop_PFI_Sto_Dacc[DFB_N
      NULL,                         /* DSPF_LUT2 */
      Sop_xrgb4444_Sto_Dacc,        /* DSPF_RGB444 */
      Sop_xrgb1555_Sto_Dacc,        /* DSPF_RGB555 */
+     Sop_argb8565_Sto_Dacc         /* DSPF_ARGB8565 */
 };
 
 /********************************* Sop_PFI_SKto_Dacc **************************/
@@ -2110,6 +2388,54 @@ static void Sop_rgb18_SKto_Dacc( GenefxS
      }
 }
 
+static void Sop_argb8565_SKto_Dacc( GenefxState *gfxs )
+{
+     int w     = gfxs->length + 1;
+     int i     = gfxs->Xphase;
+     int SperD = gfxs->SperD;
+     u32 Skey  = gfxs->Skey;
+
+     GenefxAccumulator *D = gfxs->Dacc;
+     u8                *S = gfxs->Sop[0];
+
+     while (--w) {
+          int pixelstart = (i>>16)*3;
+
+#ifdef WORDS_BIGENDIAN
+          u32 s = S[pixelstart+1] << 8 | S[pixelstart+2];
+#else
+          u32 s = S[pixelstart+1] << 8 | S[pixelstart+0];
+#endif
+
+          if (Skey != s) {
+
+#ifdef WORDS_BIGENDIAN
+               u8 a = S[pixelstart+0];
+               u8 r = (S[pixelstart+1] & 0xf8) >> 3;
+               u8 g = ((S[pixelstart+1] & 0x07) << 3)
+                      | ((S[pixelstart+2] & 0xe0) >> 5);
+               u8 b = S[pixelstart+2] & 0x1f;
+#else
+               u8 b = S[pixelstart+0] & 0x1f;
+               u8 g = ((S[pixelstart+1] & 0x07) << 3)
+                      | ((S[pixelstart+0] & 0xe0) >> 5);
+               u8 r = (S[pixelstart+1] & 0xf8) >> 3;
+               u8 a = S[pixelstart+2];
+#endif
+
+            D->RGB.a = a;
+            D->RGB.r = EXPAND_5to8 (r);
+            D->RGB.g = EXPAND_6to8 (g);
+            D->RGB.b = EXPAND_5to8 (b);
+          }
+          else
+               D->RGB.a = 0xF000;
+
+          D++;
+          i += SperD;
+     }
+}
+
 static void Sop_rgb24_SKto_Dacc( GenefxState *gfxs )
 {
      int w     = gfxs->length;
@@ -2418,6 +2744,7 @@ static GenefxFunc Sop_PFI_SKto_Dacc[DFB_
      NULL,                         /* DSPF_LUT2 */
      Sop_xrgb4444_SKto_Dacc,       /* DSPF_RGB444 */
      Sop_xrgb1555_SKto_Dacc,       /* DSPF_RGB555 */
+     Sop_argb8565_SKto_Dacc        /* DSPF_ARGB8565 */
 };
 
 /********************************* Sop_PFI_to_Dacc ****************************/
@@ -2489,6 +2816,39 @@ static void Sop_rgb18_to_Dacc( GenefxSta
      }
 }
 
+static void Sop_argb8565_to_Dacc( GenefxState *gfxs )
+{
+     int w     = gfxs->length + 1;
+
+     GenefxAccumulator *D = gfxs->Dacc;
+     const u8          *S = gfxs->Sop[0];
+
+     while (--w) {
+
+#ifdef WORDS_BIGENDIAN
+          u8 a = S[0];
+          u8 r = (S[1] & 0xf8) >> 3;
+          u8 g = ((S[1] & 0x07) << 3)
+                 | ((S[2] & 0xe0) >> 5);
+          u8 b = S[2] & 0x1f;
+#else
+          u8 b = S[0] & 0x1f;
+          u8 g = ((S[1] & 0x07) << 3)
+                 | ((S[0] & 0xe0) >> 5);
+          u8 r = (S[1] & 0xf8) >> 3;
+          u8 a = S[2];
+#endif
+
+          D->RGB.a = a;
+          D->RGB.r = EXPAND_5to8 (r);
+          D->RGB.g = EXPAND_6to8 (g);
+          D->RGB.b = EXPAND_5to8 (b);
+
+          S += 3;
+          D++;
+     }
+}
+
 static void Sop_rgb24_to_Dacc( GenefxState *gfxs )
 {
      int                w = gfxs->length;
@@ -2784,6 +3144,7 @@ static GenefxFunc Sop_PFI_to_Dacc[DFB_NU
      NULL,                         /* DSPF_LUT2 */
      Sop_xrgb4444_to_Dacc,         /* DSPF_RGB444 */
      Sop_xrgb1555_to_Dacc,         /* DSPF_RGB555 */
+     Sop_argb8565_to_Dacc          /* DSPF_ARGB8565 */
 };
 
 /********************************* Sop_PFI_Kto_Dacc ***************************/
@@ -2880,6 +3241,51 @@ static void Sop_rgb18_Kto_Dacc( GenefxSt
      }
 }
 
+static void Sop_argb8565_Kto_Dacc( GenefxState *gfxs )
+{
+     int                w    = gfxs->length + 1;
+     GenefxAccumulator *D    = gfxs->Dacc;
+     u8                *S    = gfxs->Sop[0];
+     u32                Skey = gfxs->Skey;
+
+     while (--w) {
+
+#ifdef WORDS_BIGENDIAN
+          u32 s = S[1] << 8 | S[2];
+#else
+          u32 s = S[1] << 8 | S[0];
+#endif
+
+          if (Skey != s) {
+
+#ifdef WORDS_BIGENDIAN
+               u8 a = S[0];
+               u8 r = (S[1] & 0xf8) >> 3;
+               u8 g = ((S[1] & 0x07) << 3)
+                      | ((S[2] & 0xe0) >> 5);
+               u8 b = S[2] & 0x1f;
+
+#else
+               u8 b = S[0] & 0x1f;
+               u8 g = ((S[1] & 0x07) << 3)
+                      | ((S[0] & 0xe0) >> 5);
+               u8 r = (S[1] & 0xf8) >> 3;
+               u8 a = S[2];
+#endif
+
+               D->RGB.a = a;
+               D->RGB.r = EXPAND_5to8 (r);
+               D->RGB.g = EXPAND_6to8 (g);
+               D->RGB.b = EXPAND_5to8 (b);
+          }
+          else
+               D->RGB.a = 0xF000;
+
+          S += 3;
+          D++;
+     }
+}
+
 static void Sop_rgb24_Kto_Dacc( GenefxState *gfxs )
 {
      int                w    = gfxs->length;
@@ -3179,6 +3585,7 @@ static GenefxFunc Sop_PFI_Kto_Dacc[DFB_N
      NULL,                         /* DSPF_LUT2 */
      Sop_xrgb4444_Kto_Dacc,        /* DSPF_RGB444 */
      Sop_xrgb1555_Kto_Dacc,        /* DSPF_RGB555 */
+     Sop_argb8565_Kto_Dacc         /* DSPF_ARGB8565 */
 };
 
 /********************************* Sacc_to_Aop_PFI ****************************/
@@ -3248,6 +3655,35 @@ static void Sacc_to_Aop_rgb18( GenefxSta
      }
 }
 
+static void Sacc_to_Aop_argb8565( GenefxState *gfxs )
+{
+     int                w    = gfxs->length + 1;
+     GenefxAccumulator *S = gfxs->Sacc;
+     u8                *D = gfxs->Aop[0];
+
+     while (--w) {
+          if (!(S->RGB.a & 0xF000)) {
+               u32 pixel = PIXEL_ARGB8565( (S->RGB.a & 0xFF00) ? 0xFF : S->RGB.a,
+                                           (S->RGB.r & 0xFF00) ? 0xFF : S->RGB.r,
+                                           (S->RGB.g & 0xFF00) ? 0xFF : S->RGB.g,
+                                           (S->RGB.b & 0xFF00) ? 0xFF : S->RGB.b );
+#ifdef WORDS_BIGENDIAN
+               D[0] = (pixel >> 16) & 0xff;
+               D[1] = (pixel >>  8) & 0xff;
+               D[2] = (pixel >>  0) & 0xff;
+#else
+               D[0] = (pixel >>  0) & 0xff;
+               D[1] = (pixel >>  8) & 0xff;
+               D[2] = (pixel >> 16) & 0xff;
+#endif
+
+          }
+
+          D += 3;
+          S++;
+     }
+}
+
 static void Sacc_to_Aop_rgb24( GenefxState *gfxs )
 {
      int                w = gfxs->length;
@@ -3689,6 +4125,7 @@ static GenefxFunc Sacc_to_Aop_PFI[DFB_NU
      NULL,                         /* DSPF_LUT2 */
      Sacc_to_Aop_xrgb4444,         /* DSPF_RGB444 */
      Sacc_to_Aop_xrgb1555,         /* DSPF_RGB555 */
+     Sacc_to_Aop_argb8565          /* DSPF_ARGB8565 */
 };
 
 /********************************* Sacc_Sto_Aop_PFI ***************************/
@@ -3770,6 +4207,39 @@ static void Sacc_Sto_Aop_rgb18( GenefxSt
      }
 }
  
+static void Sacc_Sto_Aop_argb8565( GenefxState *gfxs )
+{
+     int                w     = gfxs->length + 1;
+     int                i     = gfxs->Xphase;
+     GenefxAccumulator *Sacc  = gfxs->Sacc;
+     u8                *D     = gfxs->Aop[0];
+     int                SperD = gfxs->SperD;
+
+     while (--w) {
+          GenefxAccumulator *S = &Sacc[i>>16];
+
+          if (!(S->RGB.a & 0xF000)) {
+               u32 pixel = PIXEL_ARGB8565( (S->RGB.a & 0xFF00) ? 0xFF : S->RGB.a,
+                                           (S->RGB.r & 0xFF00) ? 0xFF : S->RGB.r,
+                                           (S->RGB.g & 0xFF00) ? 0xFF : S->RGB.g,
+                                           (S->RGB.b & 0xFF00) ? 0xFF : S->RGB.b );
+#ifdef WORDS_BIGENDIAN
+               D[0] = (pixel >> 16) & 0xff;
+               D[1] = (pixel >>  8) & 0xff;
+               D[2] = (pixel >>  0) & 0xff;
+#else
+               D[0] = (pixel >>  0) & 0xff;
+               D[1] = (pixel >>  8) & 0xff;
+               D[2] = (pixel >> 16) & 0xff;
+#endif
+
+          }
+
+          D += 3;
+          i += SperD;
+     }
+}
+
 static void Sacc_Sto_Aop_rgb24( GenefxState *gfxs )
 {
      int                w     = gfxs->length;
@@ -4245,6 +4715,7 @@ static GenefxFunc Sacc_Sto_Aop_PFI[DFB_N
      NULL,                         /* DSPF_LUT2 */
      Sacc_Sto_Aop_xrgb4444,        /* DSPF_RGB444 */
      Sacc_Sto_Aop_xrgb1555,        /* DSPF_RGB555 */
+     Sacc_Sto_Aop_argb8565         /* DSPF_ARGB8565 */
 };
 
 /********************************* Sacc_toK_Aop_PFI ***************************/
@@ -4317,6 +4788,43 @@ static void Sacc_toK_Aop_rgb18( GenefxSt
      }
 }
 
+static void Sacc_toK_Aop_argb8565( GenefxState *gfxs )
+{
+     int                w = gfxs->length + 1;
+     GenefxAccumulator *S = gfxs->Sacc;
+     u8                *D = gfxs->Aop[0];
+     u32                Dkey = gfxs->Dkey;
+
+     while (--w) {
+
+#ifdef WORDS_BIGENDIAN
+          u32 d = D[1] << 8 | D[2];
+#else
+          u32 d = D[1] << 8 | D[0];
+#endif
+
+          if (!(S->RGB.a & 0xF000) && Dkey == d) {
+               u32 pixel = PIXEL_ARGB8565( (S->RGB.a & 0xFF00) ? 0xFF : S->RGB.a,
+                                           (S->RGB.r & 0xFF00) ? 0xFF : S->RGB.r,
+                                           (S->RGB.g & 0xFF00) ? 0xFF : S->RGB.g,
+                                           (S->RGB.b & 0xFF00) ? 0xFF : S->RGB.b );
+#ifdef WORDS_BIGENDIAN
+               D[0] = (pixel >> 16) & 0xff;
+               D[1] = (pixel >>  8) & 0xff;
+               D[2] = (pixel >>  0) & 0xff;
+#else
+               D[0] = (pixel >>  0) & 0xff;
+               D[1] = (pixel >>  8) & 0xff;
+               D[2] = (pixel >> 16) & 0xff;
+#endif
+
+          }
+
+          D += 3;
+          S++;
+     }
+}
+
 static void Sacc_toK_Aop_rgb24( GenefxState *gfxs )
 {
      int                w = gfxs->length;
@@ -4584,10 +5092,51 @@ static GenefxFunc Sacc_toK_Aop_PFI[DFB_N
      NULL,                         /* DSPF_LUT2 */
      Sacc_toK_Aop_xrgb4444,        /* DSPF_RGB444 */
      Sacc_toK_Aop_xrgb1555,        /* DSPF_RGB555 */
+     Sacc_toK_Aop_argb8565         /* DSPF_ARGB8565 */
 };
 
 /********************************* Sacc_StoK_Aop_PFI **************************/
 
+static void Sacc_StoK_Aop_argb8565( GenefxState *gfxs )
+{
+     int                w     = gfxs->length + 1;
+     int                i     = gfxs->Xphase;
+     int                SperD = gfxs->Xphase;
+     GenefxAccumulator *Sacc  = gfxs->Sacc;
+     u8                *D     = gfxs->Aop[0];
+     u32                Dkey  = gfxs->Dkey;
+
+     while (--w) {
+          GenefxAccumulator *S = &Sacc[i>>16];
+
+#ifdef WORDS_BIGENDIAN
+          u32 d = D[1] << 8 | D[2];
+#else
+          u32 d = D[1] << 8 | D[0];
+#endif
+
+          if (!(S->RGB.a & 0xF000) && Dkey == d) {
+               u32 pixel = PIXEL_ARGB8565( (S->RGB.a & 0xFF00) ? 0xFF : S->RGB.a,
+                                           (S->RGB.r & 0xFF00) ? 0xFF : S->RGB.r,
+                                           (S->RGB.g & 0xFF00) ? 0xFF : S->RGB.g,
+                                           (S->RGB.b & 0xFF00) ? 0xFF : S->RGB.b );
+#ifdef WORDS_BIGENDIAN
+               D[0] = (pixel >> 16) & 0xff;
+               D[1] = (pixel >>  8) & 0xff;
+               D[2] = (pixel >>  0) & 0xff;
+#else
+               D[0] = (pixel >>  0) & 0xff;
+               D[1] = (pixel >>  8) & 0xff;
+               D[2] = (pixel >> 16) & 0xff;
+#endif
+
+          }
+
+          D += 3;
+          i += SperD;
+     }
+}
+
 static GenefxFunc Sacc_StoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Sacc_StoK_Aop_argb1555,       /* DSPF_ARGB1555 */
      Sacc_StoK_Aop_rgb16,          /* DSPF_RGB16 */
@@ -4617,6 +5166,7 @@ static GenefxFunc Sacc_StoK_Aop_PFI[DFB_
      NULL,                         /* DSPF_LUT2 */
      Sacc_StoK_Aop_xrgb4444,       /* DSPF_RGB444 */
      Sacc_StoK_Aop_xrgb1555,       /* DSPF_RGB555 */
+     Sacc_StoK_Aop_argb8565        /* DSPF_ARGB8565 */
 };
 
 /************** Bop_a8_set_alphapixel_Aop_PFI *********************************/
@@ -4769,6 +5319,79 @@ static void Bop_a8_set_alphapixel_Aop_rg
 
 }
 
+static void Bop_a8_set_alphapixel_Aop_argb8565( GenefxState *gfxs )
+{
+     int       w     = gfxs->length;
+     u8       *S     = gfxs->Bop[0];
+     u8       *D     = gfxs->Aop[0];
+
+     u32    Cop = gfxs->Cop | 0xff0000;
+     u32    srb = Cop & 0xf81f;
+     u32    sg  = Cop & 0x07e0;
+
+#warning CHECK correctness
+/* currently, the code is a mix of ...argb() alpha handling and the other
+   functions' color handling - they differ quite notably. But I think
+   alpha handling in ARGB / Color handling in other functions are
+   correct, whereas color handling in ARGB and alpha in others isn't. */
+#ifdef WORDS_BIGENDIAN
+#define SET_PIXEL(d,a)\
+     switch (a) {\
+          case 0xff:\
+            d[0] = (Cop >> 16) & 0xff;\
+            d[1] = (Cop >>  8) & 0xff;\
+            d[2] = (Cop >>  0) & 0xff;\
+          case 0: break;\
+          default: {\
+               register u32   s = a+1;\
+               u32           s1 = 256-a;\
+               u16          d16 = d[1] << 8 | d[2];\
+               register u32  t1 = (d16 & 0xf81f);\
+               register u32  t2 = (d16 & 0x07e0);\
+               d[0] = ((d[0] * s1) >> 8) + a;\
+               d16 = ((((srb - t1) * s + (t1 << 8)) & 0x00f81f00) + \
+                      ((( sg - t2) * s + (t2 << 8)) & 0x0007e000)) >> 8;\
+               d[1] = (d16 >> 8) & 0xff;\
+               d[2] = (d16 >> 0) & 0xff;\
+          }\
+     }
+#else
+#define SET_PIXEL(d,a)\
+     switch (a) {\
+          case 0xff:\
+            d[0] = (Cop >>  0) & 0xff;\
+            d[1] = (Cop >>  8) & 0xff;\
+            d[2] = (Cop >> 16) & 0xff;\
+          case 0: break;\
+          default: {\
+               register u32   s = a+1;\
+               u32           s1 = 256-a;\
+               u16          d16 = d[1] << 8 | d[0];\
+               register u32  t1 = (d16 & 0xf81f);\
+               register u32  t2 = (d16 & 0x07e0);\
+               d[2] = ((d[2] * s1) >> 8) + a;\
+               d16 = ((((srb - t1) * s + (t1 << 8)) & 0x00f81f00) + \
+                      ((( sg - t2) * s + (t2 << 8)) & 0x0007e000)) >> 8;\
+               d[1] = (d16 >> 8) & 0xff;\
+               d[0] = (d16 >> 0) & 0xff;\
+          }\
+     }
+#endif
+
+     while (w>4) {
+          SET_PIXEL( D, *S ); D+=3; S++;
+          SET_PIXEL( D, *S ); D+=3; S++;
+          SET_PIXEL( D, *S ); D+=3; S++;
+          SET_PIXEL( D, *S ); D+=3; S++;
+          w-=4;
+     }
+     while (w--) {
+          SET_PIXEL( D, *S ); D+=3, S++;
+     }
+
+#undef SET_PIXEL
+}
+
 static void Bop_a8_set_alphapixel_Aop_rgb24( GenefxState *gfxs )
 {
      int       w     = gfxs->length;
@@ -5129,8 +5752,10 @@ static GenefxFunc Bop_a8_set_alphapixel_
      Bop_a8_set_alphapixel_Aop_argb1666,          /* DSPF_ARGB1666 */
      Bop_a8_set_alphapixel_Aop_argb6666,          /* DSPF_ARGB6666 */
      Bop_a8_set_alphapixel_Aop_rgb18,             /* DSPF_RGB18 */
-     NULL,                                        /* DSPF_ARGB4444 */
-     NULL,                                        /* DSPF_ARGB1555 */
+     NULL,                                        /* DSPF_LUT2 */
+     NULL,                                        /* DSPF_ARGB444 */
+     NULL,                                        /* DSPF_ARGB555 */
+     Bop_a8_set_alphapixel_Aop_argb8565           /* DSPF_ARGB8565 */
 };
 
 /************** Bop_a1_set_alphapixel_Aop_PFI *********************************/
@@ -5226,6 +5851,33 @@ static void Bop_a1_set_alphapixel_Aop_rg
 
 }
 
+static void Bop_a1_set_alphapixel_Aop_argb8565( GenefxState *gfxs )
+{
+     int       i;
+     int       w   = gfxs->length;
+     u8       *S   = gfxs->Bop[0];
+     u8       *D   = gfxs->Aop[0];
+     u32       Cop = gfxs->Cop | 0xFF0000;
+
+     for (i=0; i<w; i++) {
+          if (S[i>>3] & (0x80 >> (i&7))) {
+
+#ifdef WORDS_BIGENDIAN
+               D[0] = (Cop >> 16) & 0xff;
+               D[1] = (Cop >>  8) & 0xff;
+               D[2] = (Cop >>  0) & 0xff;
+#else
+               D[0] = (Cop >>  0) & 0xff;
+               D[1] = (Cop >>  8) & 0xff;
+               D[2] = (Cop >> 16) & 0xff;
+#endif
+          }
+
+          D += 3;
+     }
+
+}
+
 static void Bop_a1_set_alphapixel_Aop_rgb24( GenefxState *gfxs )
 {
      int       i;
@@ -5432,6 +6084,7 @@ static GenefxFunc Bop_a1_set_alphapixel_
      NULL,                                        /* DSPF_LUT2 */
      NULL,                                        /* DSPF_RGB444 */
      NULL,                                        /* DSPF_RGB555 */
+     Bop_a1_set_alphapixel_Aop_argb8565           /* DSPF_ARGB8565 */
 };
 
 
@@ -6135,6 +6788,49 @@ static void Bop_argb_blend_alphachannel_
      }
 }
 
+static void Bop_argb_blend_alphachannel_src_invsrc_Aop_argb8565( GenefxState *gfxs )
+{
+     int  w = gfxs->length + 1;
+     u32 *S = gfxs->Bop[0];
+     u8  *D = gfxs->Aop[0];
+
+     while (--w) {
+#ifdef WORDS_BIGENDIAN
+          u16 dp16 = D[1] << 8 | D[2];
+#else
+          u16 dp16 = D[1] << 8 | D[0];
+#endif
+          u32 sp32   = *S++;
+          int salpha = (sp32 >> 26) + 1;
+
+#define srb (((sp32 >> 8) & 0xf800) | ((sp32 >> 3) & 0x001f))
+#define sg   ((sp32 >> 5) & 0x07e0)
+#define drb (dp16 & 0xf81f)
+#define dg  (dp16 & 0x07e0)
+
+          dp16 = ( (((srb - drb) * salpha + (drb << 6)) & 0x003e07c0)
+                  +
+                   ((( sg -  dg) * salpha + ( dg << 6)) & 0x0001f800)
+                 ) >> 6;
+
+#ifdef WORDS_BIGENDIAN
+          D[0] = 0;
+          D[1] = (dp16 >> 8) & 0xff;
+          D[2] = (dp16 >> 0) & 0xff;
+#else
+          D[0] = (dp16 >> 0) & 0xff;
+          D[1] = (dp16 >> 8) & 0xff;
+          D[2] = 0;
+#endif
+
+          D += 3;
+#undef dg
+#undef drb
+#undef sg
+#undef srb
+     }
+}
+
 static GenefxFunc Bop_argb_blend_alphachannel_src_invsrc_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      NULL,                                             /* DSPF_ARGB1555 */
      Bop_argb_blend_alphachannel_src_invsrc_Aop_rgb16, /* DSPF_RGB16 */
@@ -6164,6 +6860,7 @@ static GenefxFunc Bop_argb_blend_alphach
      NULL,                                             /* DSPF_LUT2 */
      NULL,                                             /* DSPF_RGB444 */
      NULL,                                             /* DSPF_RGB555 */
+     Bop_argb_blend_alphachannel_src_invsrc_Aop_argb8565  /* DSPF_ARGB8565 */
 };
 
 /* A8/A1 to YCbCr */
@@ -6548,6 +7245,9 @@ bool gAcquire( CardState *state, DFBAcce
           case DSPF_ARGB1555:
                gfxs->Cop = PIXEL_ARGB1555( color.a, color.r, color.g, color.b );
                break;
+          case DSPF_ARGB8565:
+               gfxs->Cop = PIXEL_ARGB8565( color.a, color.r, color.g, color.b );
+               break;
           case DSPF_RGB16:
                gfxs->Cop = PIXEL_RGB16( color.r, color.g, color.b );
                break;
@@ -6654,6 +7354,7 @@ bool gAcquire( CardState *state, DFBAcce
                case DSPF_ARGB4444:
                case DSPF_ARGB1666:
                case DSPF_ARGB6666:
+               case DSPF_ARGB8565:
                case DSPF_RGB16:
                case DSPF_RGB18:
                case DSPF_RGB24:
Index: DirectFB-1.0.1/src/idirectfb.c
===================================================================
--- DirectFB-1.0.1.orig/src/idirectfb.c	2007-09-24 14:34:21.536361164 +0100
+++ DirectFB-1.0.1/src/idirectfb.c	2007-09-24 14:34:25.080619152 +0100
@@ -466,6 +466,7 @@ IDirectFB_CreateSurface( IDirectFB      
           case DSPF_A4:
           case DSPF_A8:
           case DSPF_ARGB:
+          case DSPF_ARGB8565:
           case DSPF_ARGB1555:
           case DSPF_ARGB1666:
           case DSPF_ARGB6666:
@@ -587,6 +588,7 @@ IDirectFB_CreateSurface( IDirectFB      
                          }
 
                          switch (format) {
+                              case DSPF_ARGB8565:
                               case DSPF_ARGB4444:
                               case DSPF_ARGB2554:
                               case DSPF_ARGB1555:
Index: DirectFB-1.0.1/src/misc/conf.c
===================================================================
--- DirectFB-1.0.1.orig/src/misc/conf.c	2007-09-24 14:34:21.552362333 +0100
+++ DirectFB-1.0.1/src/misc/conf.c	2007-09-24 14:34:25.080619152 +0100
@@ -186,6 +186,7 @@ static const FormatString format_strings
      { "ARGB2554", DSPF_ARGB2554 },
      { "ARGB4444", DSPF_ARGB4444 },
      { "ARGB6666", DSPF_ARGB6666 },
+     { "ARGB8565", DSPF_ARGB8565 },
      { "AYUV",     DSPF_AYUV     },
      { "AiRGB",    DSPF_AiRGB    },
      { "I420",     DSPF_I420     },
@@ -216,6 +217,7 @@ static const FormatString font_format_st
      { "ARGB1555", DSPF_ARGB1555 },
      { "ARGB2554", DSPF_ARGB2554 },
      { "ARGB4444", DSPF_ARGB4444 },
+     { "ARGB8565", DSPF_ARGB8565 },
      { "AiRGB",    DSPF_AiRGB    },
      { "LUT2",     DSPF_LUT2     }
 };
Index: DirectFB-1.0.1/src/misc/gfx_util.c
===================================================================
--- DirectFB-1.0.1.orig/src/misc/gfx_util.c	2007-09-24 14:34:21.580364366 +0100
+++ DirectFB-1.0.1/src/misc/gfx_util.c	2007-09-24 14:34:25.080619152 +0100
@@ -133,6 +133,21 @@ static void write_argb_span (u32 *src, u
                     ((u16*)d)[i] = ARGB_TO_ARGB4444( src[i] );
                break;
                
+          case DSPF_ARGB8565:
+               for (i = 0, j = -1; i < len; i++) {
+                    register u32 pixel = ARGB_TO_ARGB8565 ( src[i] );
+#ifdef WORDS_BIGENDIAN
+                    d[++j] = (pixel >> 16) & 0xff;
+                    d[++j] = (pixel >>  8) & 0xff;
+                    d[++j] = (pixel >>  0) & 0xff;
+#else
+                    d[++j] = (pixel >>  0) & 0xff;
+                    d[++j] = (pixel >>  8) & 0xff;
+                    d[++j] = (pixel >> 16) & 0xff;
+#endif
+               }
+               break;
+
           case DSPF_RGB16:
                for (i = 0; i < len; i++)
                     ((u16*)d)[i] = RGB32_TO_RGB16( src[i] );
Index: DirectFB-1.0.1/systems/fbdev/fbdev.c
===================================================================
--- DirectFB-1.0.1.orig/systems/fbdev/fbdev.c	2007-09-24 14:34:21.608366399 +0100
+++ DirectFB-1.0.1/systems/fbdev/fbdev.c	2007-09-24 14:34:25.080619152 +0100
@@ -1615,6 +1615,12 @@ static DFBSurfacePixelFormat dfb_fbdev_g
                if (dfb_fbdev_compatible_format( var, 0, 8, 8, 8, 0, 16, 8, 0 ))
                     return DSPF_RGB24;
 
+               if (dfb_fbdev_compatible_format( var, 0, 8, 8, 8, 0, 16, 8, 0 ))
+                    return DSPF_RGB24;
+
+               if (dfb_fbdev_compatible_format( var, 8, 5, 6, 5, 16, 11, 5, 0 ))
+                    return DSPF_ARGB8565;
+
                break;
 
           case 32:
@@ -1826,6 +1832,11 @@ static DFBResult dfb_fbdev_set_mode( Cor
                    var.blue.offset   = 0;
                    break;
 
+               case DSPF_ARGB8565:
+                   var.transp.length = 8;
+                   var.transp.offset = 16;
+                   /* fall through */
+
                case DSPF_RGB16:
                     var.red.length    = 5;
                     var.green.length  = 6;
@@ -2309,6 +2320,7 @@ static DFBResult dfb_fbdev_set_gamma_ram
           case DSPF_ARGB4444:
           case DSPF_RGB444:
           case DSPF_RGB16:
+          case DSPF_ARGB8565:
                red_size   = 32;
                green_size = 64;
                blue_size  = 32;
Index: DirectFB-1.0.1/tools/directfb-csource.c
===================================================================
--- DirectFB-1.0.1.orig/tools/directfb-csource.c	2007-09-24 14:34:21.636368437 +0100
+++ DirectFB-1.0.1/tools/directfb-csource.c	2007-09-24 14:34:25.084619443 +0100
@@ -58,6 +58,7 @@ static struct {
      { DSPF_ARGB1555, "ARGB1555" },
      { DSPF_ARGB2554, "ARGB2554" },
      { DSPF_ARGB4444, "ARGB4444" },
+     { DSPF_ARGB8565, "ARGB8565" },
      { DSPF_RGB32,    "RGB32"    },
      { DSPF_RGB24,    "RGB24"    },
      { DSPF_RGB16,    "RGB16"    },
@@ -461,6 +462,10 @@ static DFBResult load_image (const char 
                     for (s = data, d = dest; h; h--, s += pitch, d += d_pitch)
                          dfb_argb_to_argb4444 ((u32 *) s, (u16 *) d, width);
                     break;
+               case DSPF_ARGB8565:
+                    for (s = data, d = dest; h; h--, s += pitch, d += d_pitch)
+                         dfb_argb_to_argb8565 ((u32 *) s, (u8 *) d, width);
+                    break;
                case DSPF_RGB332:
                     for (s = data, d = dest; h; h--, s += pitch, d += d_pitch)
                          dfb_argb_to_rgb332 ((u32 *) s, (u8 *) d, width);
Index: DirectFB-1.0.1/tools/mkdfiff.c
===================================================================
--- DirectFB-1.0.1.orig/tools/mkdfiff.c	2007-09-24 14:34:21.664370480 +0100
+++ DirectFB-1.0.1/tools/mkdfiff.c	2007-09-24 14:34:25.084619443 +0100
@@ -220,6 +220,10 @@ load_image (const char            *filen
                     for (s = data, d = dest; h; h--, s += pitch, d += d_pitch)
                          dfb_argb_to_rgb16 ((u32 *) s, (u16 *) d, width);
                     break;
+               case DSPF_ARGB8565:
+                    for (s = data, d = dest; h; h--, s += pitch, d += d_pitch)
+                         dfb_argb_to_argb8565 ((u32 *) s, (u8 *) d, width);
+                    break;
                case DSPF_ARGB1555:
                     for (s = data, d = dest; h; h--, s += pitch, d += d_pitch)
                          dfb_argb_to_argb1555 ((u32 *) s, (u16 *) d, width);
Index: DirectFB-1.0.1/tools/mkdgiff.c
===================================================================
--- DirectFB-1.0.1.orig/tools/mkdgiff.c	2007-09-24 14:34:21.692372518 +0100
+++ DirectFB-1.0.1/tools/mkdgiff.c	2007-09-24 14:34:25.084619443 +0100
@@ -259,6 +259,20 @@ write_glyph( DGIFFGlyphInfo *glyph, FT_G
                               for (i=0; i<glyph->width; i++)
                                    dst32[i] = ((src[i] ^ 0xFF) << 24) | 0xFFFFFF;
                               break;
+                         case DSPF_ARGB8565:
+                              for (i=0, j = -1; i<glyph->width; ++i) {
+                                   u32 d = (src[i] << 16) | 0xFFFF;
+#ifdef WORDS_BIGENDIAN
+                                   dst8[++j] = (d >> 16) & 0xff;
+                                   dst8[++j] = (d >>  8) & 0xff;
+                                   dst8[++j] = (d >>  0) & 0xff;
+#else
+                                   dst8[++j] = (d >>  0) & 0xff;
+                                   dst8[++j] = (d >>  8) & 0xff;
+                                   dst8[++j] = (d >> 16) & 0xff;
+#endif
+                              }
+                              break;
                          case DSPF_ARGB4444:
                               for (i=0; i<glyph->width; i++)
                                    dst16[i] = (src[i] << 8) | 0xFFF;
@@ -305,6 +319,21 @@ write_glyph( DGIFFGlyphInfo *glyph, FT_G
                                    dst32[i] = (((src[i>>3] & (1<<(7-(i%8)))) ?
                                                 0x00 : 0xFF) << 24) | 0xFFFFFF;
                               break;
+                         case DSPF_ARGB8565:
+                              for (i=0, j = -1; i<glyph->width; ++i) {
+                                   u32 d = (((src[i>>3] & (1<<(7-(i%8)))) ?
+                                             0xFF : 0x00) << 16) | 0xFFFF;
+#ifdef WORDS_BIGENDIAN
+                                   dst8[++j] = (d >> 16) & 0xff;
+                                   dst8[++j] = (d >>  8) & 0xff;
+                                   dst8[++j] = (d >>  0) & 0xff;
+#else
+                                   dst8[++j] = (d >>  0) & 0xff;
+                                   dst8[++j] = (d >>  8) & 0xff;
+                                   dst8[++j] = (d >> 16) & 0xff;
+#endif
+                              }
+                              break;
                          case DSPF_ARGB4444:
                               for (i=0; i<glyph->width; i++)
                                    dst16[i] = (((src[i>>3] & (1<<(7-(i%8)))) ?
Index: DirectFB-1.0.1/wm/default/default.c
===================================================================
--- DirectFB-1.0.1.orig/wm/default/default.c	2007-09-24 14:34:21.720374554 +0100
+++ DirectFB-1.0.1/wm/default/default.c	2007-09-24 14:34:25.084619443 +0100
@@ -388,6 +388,16 @@ window_at_pointer( CoreWindowStack *stac
                                    case DSPF_AYUV:
                                         alpha = *(u32*)(data + 4 * wx + pitch * wy) >> 24;
                                         break;
+                                   case DSPF_ARGB8565:
+                                        {
+                                        u8 *p = (data + 3 * wx + pitch * wy);
+#ifdef WORDS_BIGENDIAN
+                                        alpha = p[0];
+#else
+                                        alpha = p[2];
+#endif
+                                        }
+                                        break;
                                    case DSPF_ARGB1555:
                                    case DSPF_ARGB2554:
                                    case DSPF_ARGB4444:
@@ -456,6 +466,15 @@ window_at_pointer( CoreWindowStack *stac
                                                 & 0xfff;
                                         break;
 
+                                   case DSPF_ARGB8565:
+                                        p = (data + 3 * wx + pitch * wy);
+#ifdef WORDS_BIGENDIAN
+                                        pixel = p[1] << 8 | p[2];
+#else
+                                        pixel = p[1] << 8 | p[0];
+#endif
+                                     break;
+
                                    case DSPF_ARGB1555:
                                    case DSPF_RGB555:
                                         pixel = *(u16*)(data + 2 * wx +
Add support for the 4:4:4 YUV and AYUV color formats to DirectFB.
We do some byte swapping to match the STM blitter hardware format, which
is (A)VYU. Please note, that not all software fallbacks are implemented and
some produce wrong results, most notably colorkeying doesn't work reliably
because of colorspace differences and alpha blended blitting doesn't work
correctly for the AYUV format.

Signed of by: Andre' Draszik <andre.draszik@st.com>

Index: DirectFB-1.0.1/include/directfb.h
===================================================================
--- DirectFB-1.0.1.orig/include/directfb.h	2007-09-24 14:34:25.068618276 +0100
+++ DirectFB-1.0.1/include/directfb.h	2007-09-24 14:35:09.547854587 +0100
@@ -1017,12 +1017,18 @@ typedef enum {
      DSPF_RGB555    = DFB_SURFACE_PIXELFORMAT( 27, 15, 0, 0, 0, 2, 0, 0, 0, 0, 0 ),
 
      /* 16 bit  ARGB (3 byte, alpha 8@16, red 5@11, green 6@5, blue 5@0) */
-     DSPF_ARGB8565  = DFB_SURFACE_PIXELFORMAT( 28, 16, 8, 1, 0, 3, 0, 0, 0, 0, 0 )
+     DSPF_ARGB8565  = DFB_SURFACE_PIXELFORMAT( 28, 16, 8, 1, 0, 3, 0, 0, 0, 0, 0 ),
+
+     /* 32 bit  AUYV 4:4:4 (4 byte, alpha 8@24, Cr 8@16, Y 8@8, Cb 8@0) */
+     DSPF_AVYU      = DFB_SURFACE_PIXELFORMAT( 29, 24, 8, 1, 0, 4, 0, 0, 0, 0, 0 ),
+
+     /* 24 bit   VYU 4:4:4 (3 byte, Cr 8@16, Y 8@8, Cb 8@0) */
+     DSPF_VYU       = DFB_SURFACE_PIXELFORMAT( 30, 24, 0, 0, 0, 3, 0, 0, 0, 0, 0 ),
 
 } DFBSurfacePixelFormat;
 
 /* Number of pixelformats defined */
-#define DFB_NUM_PIXELFORMATS            29
+#define DFB_NUM_PIXELFORMATS            31
 
 /* These macros extract information about the pixel format. */
 #define DFB_PIXELFORMAT_INDEX(fmt)      (((fmt) & 0x0000007F)      )
Index: DirectFB-1.0.1/src/core/surfaces.c
===================================================================
--- DirectFB-1.0.1.orig/src/core/surfaces.c	2007-09-24 14:34:25.072618571 +0100
+++ DirectFB-1.0.1/src/core/surfaces.c	2007-09-24 14:35:09.547854587 +0100
@@ -1101,6 +1101,7 @@ DFBResult dfb_surface_init ( CoreDFB    
           case DSPF_ARGB2554:
           case DSPF_ARGB4444:
           case DSPF_AYUV:
+          case DSPF_AVYU:
           case DSPF_AiRGB:
           case DSPF_I420:
           case DSPF_LUT2:
@@ -1116,6 +1117,7 @@ DFBResult dfb_surface_init ( CoreDFB    
           case DSPF_UYVY:
           case DSPF_YUY2:
           case DSPF_YV12:
+          case DSPF_VYU:
           case DSPF_RGB444:
           case DSPF_RGB555:
                break;
Index: DirectFB-1.0.1/src/gfx/convert.c
===================================================================
--- DirectFB-1.0.1.orig/src/gfx/convert.c	2007-09-24 14:34:25.072618571 +0100
+++ DirectFB-1.0.1/src/gfx/convert.c	2007-09-24 14:35:09.551854880 +0100
@@ -117,6 +117,11 @@ dfb_color_to_pixel( DFBSurfacePixelForma
                RGB_TO_YCBCR( r, g, b, y, cb, cr );
                pixel = PIXEL_AYUV( 0, y, cb, cr );
                break;
+          case DSPF_AVYU:
+          case DSPF_VYU:
+               RGB_TO_YCBCR( r, g, b, y, cb, cr );
+               pixel = PIXEL_AVYU( 0, y, cb, cr );
+               break;
           case DSPF_YUY2:
                RGB_TO_YCBCR( r, g, b, y, cb, cr );
                pixel = PIXEL_YUY2( y, cb, cr );
@@ -293,6 +298,12 @@ dfb_pixelformat_name( DFBSurfacePixelFor
           case DSPF_AYUV:
                return "AYUV";
 
+          case DSPF_AVYU:
+               return "AVYU";
+
+          case DSPF_VYU:
+               return "VYU";
+
           case DSPF_A4:
                return "A4";
 
Index: DirectFB-1.0.1/src/gfx/convert.h
===================================================================
--- DirectFB-1.0.1.orig/src/gfx/convert.h	2007-09-24 14:34:25.072618571 +0100
+++ DirectFB-1.0.1/src/gfx/convert.h	2007-09-24 14:35:09.551854880 +0100
@@ -99,6 +99,11 @@
                                  ((u) << 8)  | \
                                   (v) )
 
+#define PIXEL_AVYU(a,y,u,v)    ( ((a) << 24) | \
+                                 ((v) << 16) | \
+                                 ((y) << 8)  | \
+                                  (u) )
+
 #define PIXEL_AiRGB(a,r,g,b)   ( (((a) ^ 0xff) << 24) | \
                                  ((r) << 16) | \
                                  ((g) << 8)  | \
@@ -115,6 +120,10 @@
                                  ((u) << 16) | \
                                  ((y) << 8)  | \
                                   (v) )
+
+#define PIXEL_VYU(y,u,v)       ( ((v) << 16) | \
+                                 ((y) << 8)  | \
+                                  (u) )
 #else /* little endian */
 
 #define PIXEL_YUY2(y,u,v)      ( ((v) << 24) | \
@@ -127,6 +136,10 @@
                                  ((y) << 8)  | \
                                   (u) )
 
+#define PIXEL_VYU(y,u,v)       ( ((u) << 16) | \
+                                 ((y) << 8)  | \
+                                  (v) )
+
 #endif
 
 
@@ -377,6 +390,21 @@ dfb_color_to_aycbcr( const DFBColor *col
      return (color->a << 24) | (y << 16) | (cb << 8) | cr;
 }
 
+static inline u32
+dfb_color_to_acrycb( const DFBColor *color )
+{
+     unsigned int red   = color->r;
+     unsigned int green = color->g;
+     unsigned int blue  = color->b;
+
+     u8 y  = (u8)(((66 * red + 129 * green + 25 * blue) / 256) + 16);
+
+     u8 cb = (u8)((128 * 256 -  38 * red   - 74 * green + 112 * blue) / 256);
+     u8 cr = (u8)((128 * 256 + 112 * red   - 94 * green -  18 * blue) / 256);
+
+     return (color->a << 24) | (cr << 16) | (y << 8) | cb;
+}
+
 static inline void
 dfb_argb_to_rgb332( u32 *src, u8 *dst, int len )
 {
Index: DirectFB-1.0.1/src/gfx/generic/generic.c
===================================================================
--- DirectFB-1.0.1.orig/src/gfx/generic/generic.c	2007-09-24 14:34:25.076618862 +0100
+++ DirectFB-1.0.1/src/gfx/generic/generic.c	2007-09-24 14:35:09.555855173 +0100
@@ -470,7 +470,9 @@ static GenefxFunc Cop_to_Aop_PFI[DFB_NUM
      NULL,               /* DSPF_LUT2 */
      Cop_to_Aop_16,      /* DSPF_RGB444 */
      Cop_to_Aop_16,      /* DSPF_RGB555 */
-     Cop_to_Aop_argb8565 /* DSPF_ARGB8565 */
+     Cop_to_Aop_argb8565,/* DSPF_ARGB8565 */
+     Cop_to_Aop_32,      /* DSPF_AVYU */
+     Cop_to_Aop_argb8565 /* DSPF_VYU */
 };
 
 /********************************* Cop_toK_Aop_PFI ****************************/
@@ -607,6 +609,48 @@ static void Cop_toK_Aop_alut44( GenefxSt
      }
 }
 
+static void Cop_toK_Aop_avyu( GenefxState *gfxs )
+{
+     int l = gfxs->length;
+     u32 *D = gfxs->Aop[0];
+     u32 Dkey = gfxs->Dkey;
+     u32 Cop = gfxs->Cop;
+
+     while (l--) {
+          if ((*D & 0x00ffffff) == Dkey)
+               *D = Cop;
+
+          D++;
+     }
+}
+
+static void Cop_toK_Aop_vyu( GenefxState *gfxs )
+{
+     int  w    = gfxs->length + 1;
+     u8  *D    = gfxs->Aop[0];
+     u32  Dkey = gfxs->Dkey;
+     u32  Cop  = gfxs->Cop;
+
+     while (--w) {
+
+#ifdef WORDS_BIGENDIAN
+          if (Dkey == (u32) ((D[0]<<16) | (D[1]<<8) | D[2])) {
+               D[0] = (Cop >> 16) & 0xff;
+               D[1] = (Cop >>  8) & 0xff;
+               D[2] = (Cop >>  0) & 0xff;
+          }
+#else
+          if (Dkey == (u32) ((D[2]<<16) | (D[1]<<8) | D[0])) {
+               D[0] = (Cop >>  0) & 0xff;
+               D[1] = (Cop >>  8) & 0xff;
+               D[2] = (Cop >> 16) & 0xff;
+          }
+#endif
+
+          D += 3;
+     }
+}
+
 static GenefxFunc Cop_toK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Cop_toK_Aop_15,          /* DSPF_ARGB1555 */
      Cop_toK_Aop_16,          /* DSPF_RGB16 */
@@ -636,7 +680,9 @@ static GenefxFunc Cop_toK_Aop_PFI[DFB_NU
      NULL,                    /* DSPF_LUT2 */
      Cop_toK_Aop_12,          /* DSPF_RGB444 */
      Cop_toK_Aop_15,          /* DSPF_RGB555 */
-     Cop_toK_Aop_argb8565     /* DSPF_ARGB8565 */
+     Cop_toK_Aop_argb8565,    /* DSPF_ARGB8565 */
+     Cop_toK_Aop_avyu,        /* DSPF_AVYU */
+     Cop_toK_Aop_vyu          /* DSPF_VYU */
 };
 
 /********************************* Bop_PFI_to_Aop_PFI *************************/
@@ -711,7 +757,9 @@ static GenefxFunc Bop_PFI_to_Aop_PFI[DFB
      NULL,               /* DSPF_LUT2 */
      Bop_16_to_Aop,      /* DSPF_RGB444 */
      Bop_16_to_Aop,      /* DSPF_RGB555 */
-     Bop_24_to_Aop       /* DSPF_ARGB8565 */
+     Bop_24_to_Aop,      /* DSPF_ARGB8565 */
+     Bop_32_to_Aop,      /* DSPF_AVYU */
+     Bop_24_to_Aop       /* DSPF_VYU */
 };
 
 /********************************* Bop_PFI_Kto_Aop_PFI ************************/
@@ -955,7 +1003,9 @@ static GenefxFunc Bop_PFI_Kto_Aop_PFI[DF
      NULL,                    /* DSPF_LUT2 */
      Bop_12_Kto_Aop,          /* DSPF_RGB444 */
      Bop_15_Kto_Aop,          /* DSPF_RGB555 */
-     Bop_argb8565_Kto_Aop     /* DSPF_ARGB8565 */
+     Bop_argb8565_Kto_Aop,    /* DSPF_ARGB8565 */
+     Bop_32_Kto_Aop,          /* DSPF_AVYU */
+     Bop_rgb24_Kto_Aop        /* DSPF_VYU */
 };
 
 /********************************* Bop_PFI_toK_Aop_PFI ************************/
@@ -1118,7 +1168,9 @@ static GenefxFunc Bop_PFI_toK_Aop_PFI[DF
      NULL,                    /* DSPF_LUT2 */
      Bop_12_toK_Aop,          /* DSPF_RGB444 */
      Bop_15_toK_Aop,          /* DSPF_RGB555 */
-     Bop_argb8565_toK_Aop     /* DSPF_ARGB8565 */
+     Bop_argb8565_toK_Aop,    /* DSPF_ARGB8565 */
+     Bop_32_toK_Aop,          /* DSPF_AVYU */
+     Bop_rgb24_toK_Aop        /* DSPF_VYU */
 };
 
 /********************************* Bop_PFI_KtoK_Aop_PFI ***********************/
@@ -1158,6 +1210,41 @@ static void Bop_argb8565_KtoK_Aop( Genef
      }
 }
 
+static void Bop_vyu_KtoK_Aop( GenefxState *gfxs )
+{
+     int  l     = gfxs->length + 1;
+     int  Ostep = gfxs->Ostep;
+     u8  *S     = gfxs->Bop[0];
+     u8  *D     = gfxs->Aop[0];
+     u32  Skey  = gfxs->Skey;
+     u32  Dkey  = gfxs->Dkey;
+
+     if (Ostep < 0) {
+          D += (gfxs->length - 1) * 3;
+          S += (gfxs->length - 1) * 3;
+     }
+
+     while (--l) {
+
+#ifdef WORDS_BIGENDIAN
+          u32 s = S[0] << 16 | S[1] << 8 | S[2];
+          u32 d = D[0] << 16 | D[1] << 8 | D[2];
+#else
+          u32 s = S[2] << 16 | S[1] << 8 | S[0];
+          u32 d = S[2] << 16 | D[1] << 8 | D[0];
+#endif
+
+          if (Skey != s && Dkey == d) {
+               D[0] = S[0];
+               D[1] = S[1];
+               D[2] = S[2];
+          }
+
+          S += Ostep * 3;
+          D += Ostep * 3;
+     }
+}
+
 static GenefxFunc Bop_PFI_KtoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Bop_15_KtoK_Aop,         /* DSPF_ARGB1555 */
      Bop_16_KtoK_Aop,         /* DSPF_RGB16 */
@@ -1187,7 +1274,9 @@ static GenefxFunc Bop_PFI_KtoK_Aop_PFI[D
      NULL,                    /* DSPF_LUT2 */
      Bop_12_KtoK_Aop,         /* DSPF_RGB444 */
      Bop_15_KtoK_Aop,         /* DSPF_RGB555 */
-     Bop_argb8565_KtoK_Aop    /* DSPF_ARGB8565 */
+     Bop_argb8565_KtoK_Aop,   /* DSPF_ARGB8565 */
+     Bop_32_KtoK_Aop,         /* DSPF_AVYU */
+     Bop_vyu_KtoK_Aop         /* DSPF_VYU */
 };
 
 /********************************* Bop_PFI_Sto_Aop_PFI ************************/
@@ -1433,7 +1522,9 @@ static GenefxFunc Bop_PFI_Sto_Aop_PFI[DF
      NULL,                    /* DSPF_LUT2 */
      Bop_16_Sto_Aop,          /* DSPF_ARGB444 */
      Bop_16_Sto_Aop,          /* DSPF_ARGB555 */
-     Bop_24_Sto_Aop           /* DSPF_ARGB8565 */
+     Bop_24_Sto_Aop,          /* DSPF_ARGB8565 */
+     Bop_32_Sto_Aop,          /* DSPF_AVYU */
+     Bop_24_Sto_Aop           /* DSPF_VYU */
 };
 
 /********************************* Bop_PFI_SKto_Aop_PFI ***********************/
@@ -1717,7 +1808,9 @@ static GenefxFunc Bop_PFI_SKto_Aop_PFI[D
      NULL,                    /* DSPF_LUT2 */
      Bop_12_SKto_Aop,         /* DSPF_RGB444 */
      Bop_15_SKto_Aop,         /* DSPF_RGB555 */
-     Bop_argb8565_SKto_Aop    /* DSPF_ARGB8565 */
+     Bop_argb8565_SKto_Aop,   /* DSPF_ARGB8565 */
+     Bop_32_SKto_Aop,         /* DSPF_AVYU */
+     Bop_rgb24_SKto_Aop       /* DSPF_VYU */
 };
 
 /********************************* Bop_PFI_StoK_Aop_PFI ***********************/
@@ -1751,6 +1844,35 @@ static void Bop_argb8565_StoK_Aop( Genef
      }
 }
 
+static void Bop_vyu_StoK_Aop( GenefxState *gfxs )
+{
+     int  l     = gfxs->length + 1;
+     int  i     = gfxs->Xphase;
+     int  SperD = gfxs->SperD;
+     u8  *S     = gfxs->Bop[0];
+     u8  *D     = gfxs->Aop[0];
+     u32  Dkey  = gfxs->Dkey;
+
+     while (--l) {
+          int pixelstart = (i >> 16) * 3;
+
+#ifdef WORDS_BIGENDIAN
+          u32 d = D[0] << 16 | D[1] << 8 | D[2];
+#else
+          u32 d = D[2] << 16 | D[1] << 8 | D[0];
+#endif
+
+          if (Dkey != d) {
+               D[0] = S[pixelstart+0];
+               D[1] = S[pixelstart+1];
+               D[2] = S[pixelstart+2];
+          }
+
+          D += 3;
+          i += SperD;
+     }
+}
+
 static GenefxFunc Bop_PFI_StoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Bop_15_StoK_Aop,         /* DSPF_ARGB1555 */
      Bop_16_StoK_Aop,         /* DSPF_RGB16 */
@@ -1780,7 +1902,9 @@ static GenefxFunc Bop_PFI_StoK_Aop_PFI[D
      NULL,                    /* DSPF_LUT2 */
      Bop_12_StoK_Aop,         /* DSPF_RGB444 */
      Bop_15_StoK_Aop,         /* DSPF_RGB555 */
-     Bop_argb8565_StoK_Aop    /* DSPF_ARGB8565 */
+     Bop_argb8565_StoK_Aop,   /* DSPF_ARGB8565 */
+     Bop_32_StoK_Aop,         /* DSPF_AVYU */
+     Bop_vyu_StoK_Aop         /* DSPF_VYU */
 };
 
 /********************************* Bop_PFI_SKtoK_Aop_PFI **********************/
@@ -1817,6 +1941,38 @@ static void Bop_argb8565_SKtoK_Aop( Gene
      }
 }
 
+static void Bop_vyu_SKtoK_Aop( GenefxState *gfxs )
+{
+     int  l     = gfxs->length + 1;
+     int  i     = gfxs->Xphase;
+     int  SperD = gfxs->SperD;
+     u8  *S     = gfxs->Bop[0];
+     u8  *D     = gfxs->Aop[0];
+     u32  Skey  = gfxs->Skey;
+     u32  Dkey  = gfxs->Dkey;
+
+     while (--l) {
+          int pixelstart = (i >> 16) * 3;
+
+#ifdef WORDS_BIGENDIAN
+          u32 s = S[pixelstart+0] << 16 | S[pixelstart+1] << 8 | S[pixelstart+2];
+          u32 d = D[           0] << 16 | D[           1] << 8 | D[           2];
+#else
+          u32 s = S[pixelstart+2] << 16 | S[pixelstart+1] << 8 | S[pixelstart+0];
+          u32 d = D[           2] << 16 | D[           1] << 8 | D[           0];
+#endif
+
+          if (Skey != s && Dkey == d) {
+               D[0] = S[pixelstart+0];
+               D[1] = S[pixelstart+1];
+               D[2] = S[pixelstart+2];
+          }
+
+          D += 3;
+          i += SperD;
+     }
+}
+
 static GenefxFunc Bop_PFI_SKtoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Bop_15_SKtoK_Aop,        /* DSPF_ARGB1555 */
      Bop_16_SKtoK_Aop,        /* DSPF_RGB16 */
@@ -1846,7 +2002,9 @@ static GenefxFunc Bop_PFI_SKtoK_Aop_PFI[
      NULL,                    /* DSPF_LUT2 */
      Bop_12_SKtoK_Aop,        /* DSPF_RGB444 */
      Bop_15_SKtoK_Aop,        /* DSPF_RGB555 */
-     Bop_argb8565_SKtoK_Aop   /* DSPF_ARGB8565 */
+     Bop_argb8565_SKtoK_Aop,  /* DSPF_ARGB8565 */
+     Bop_32_SKtoK_Aop,        /* DSPF_AVYU */
+     Bop_vyu_SKtoK_Aop        /* DSPF_VYU */
 };
 
 /********************************* Sop_PFI_Sto_Dacc ***************************/
@@ -2248,6 +2406,58 @@ static void Sop_ayuv_Sto_Dacc( GenefxSta
      }
 }
 
+static void Sop_avyu_Sto_Dacc( GenefxState *gfxs )
+{
+     int w     = gfxs->length;
+     int i     = gfxs->Xphase;
+     int SperD = gfxs->SperD;
+
+     GenefxAccumulator *D = gfxs->Dacc;
+     u32               *S = gfxs->Sop[0];
+
+     while (w--) {
+          u32 s = S[i>>16];
+
+          D->YUV.a = (s >> 24);
+          D->YUV.v = (s >> 16) & 0xff;
+          D->YUV.y = (s >>  8) & 0xff;
+          D->YUV.u = (s      ) & 0xff;
+
+          i += SperD;
+
+          D++;
+     }
+}
+
+static void Sop_vyu_Sto_Dacc( GenefxState *gfxs )
+{
+     int w     = gfxs->length + 1;
+     int i     = gfxs->Xphase;
+     int SperD = gfxs->SperD;
+
+     GenefxAccumulator *D = gfxs->Dacc;
+     u8                *S = gfxs->Sop[0];
+
+     while (--w) {
+          int pixelstart = (i >> 16) * 3;
+
+#ifdef WORDS_BIGENDIAN
+          D->YUV.a = 0xff;
+          D->YUV.v = S[pixelstart+0];
+          D->YUV.y = S[pixelstart+1];
+          D->YUV.u = S[pixelstart+2];
+#else
+          D->YUV.a = 0xff;
+          D->YUV.v = S[pixelstart+2];
+          D->YUV.y = S[pixelstart+1];
+          D->YUV.u = S[pixelstart+0];
+#endif
+
+          D++;
+          i += SperD;
+     }
+}
+
 static GenefxFunc Sop_PFI_Sto_Dacc[DFB_NUM_PIXELFORMATS] = {
      Sop_argb1555_Sto_Dacc,        /* DSPF_ARGB1555 */
      Sop_rgb16_Sto_Dacc,           /* DSPF_RGB16 */
@@ -2277,7 +2487,9 @@ static GenefxFunc Sop_PFI_Sto_Dacc[DFB_N
      NULL,                         /* DSPF_LUT2 */
      Sop_xrgb4444_Sto_Dacc,        /* DSPF_RGB444 */
      Sop_xrgb1555_Sto_Dacc,        /* DSPF_RGB555 */
-     Sop_argb8565_Sto_Dacc         /* DSPF_ARGB8565 */
+     Sop_argb8565_Sto_Dacc,        /* DSPF_ARGB8565 */
+     Sop_avyu_Sto_Dacc,            /* DSPF_AVYU */
+     Sop_vyu_Sto_Dacc              /* DSPF_VYU */
 };
 
 /********************************* Sop_PFI_SKto_Dacc **************************/
@@ -2715,6 +2927,73 @@ static void Sop_uyvy_SKto_Dacc( GenefxSt
      }
 }
 
+static void Sop_avyu_SKto_Dacc( GenefxState *gfxs )
+{
+     int l = gfxs->length;
+     int i = gfxs->Xphase;
+     int SperD = gfxs->SperD;
+     u32 *S = gfxs->Sop[0];
+     GenefxAccumulator *D = gfxs->Dacc;
+     u32 Skey = gfxs->Skey;
+
+     while (l--) {
+          u32 s = S[i>>16];
+
+          if ((s & 0x00ffffff) != Skey) {
+               D->YUV.a = (s & 0xff000000) >> 24;
+               D->YUV.v = (s & 0x00ff0000) >> 16;
+               D->YUV.y = (s & 0x0000ff00) >>  8;
+               D->YUV.u = (s & 0x000000ff) >>  0;
+          }
+          else
+               D->YUV.a = 0xf000;
+
+          D++;
+          i += SperD;
+     }
+}
+
+static void Sop_vyu_SKto_Dacc( GenefxState *gfxs )
+{
+     int w     = gfxs->length + 1;
+     int i     = gfxs->Xphase;
+     int SperD = gfxs->SperD;
+     u32 Skey  = gfxs->Skey;
+
+     GenefxAccumulator *D = gfxs->Dacc;
+     u8                *S = gfxs->Sop[0];
+
+     while (--w) {
+          int pixelstart = (i>>16)*3;
+
+#ifdef WORDS_BIGENDIAN
+          u32 s = S[pixelstart+0] << 16 | S[pixelstart+1] << 8 | S[pixelstart+2];
+#else
+          u32 s = S[pixelstart+2] << 16 | S[pixelstart+1] << 8 | S[pixelstart+0];
+#endif
+
+          if (Skey != s) {
+
+#ifdef WORDS_BIGENDIAN
+               D->YUV.a = 0xff;
+               D->YUV.v = S[pixelstart+0];
+               D->YUV.y = S[pixelstart+1];
+               D->YUV.u = S[pixelstart+2];
+#else
+               D->YUV.a = 0xff;
+               D->YUV.u = S[pixelstart+2];
+               D->YUV.y = S[pixelstart+1];
+               D->YUV.v = S[pixelstart+0];
+#endif
+          }
+          else
+               D->YUV.a = 0xF000;
+
+          D++;
+          i += SperD;
+     }
+}
+
 static GenefxFunc Sop_PFI_SKto_Dacc[DFB_NUM_PIXELFORMATS] = {
      Sop_argb1555_SKto_Dacc,       /* DSPF_ARGB1555 */
      Sop_rgb16_SKto_Dacc,          /* DSPF_RGB16 */
@@ -2744,7 +3023,9 @@ static GenefxFunc Sop_PFI_SKto_Dacc[DFB_
      NULL,                         /* DSPF_LUT2 */
      Sop_xrgb4444_SKto_Dacc,       /* DSPF_RGB444 */
      Sop_xrgb1555_SKto_Dacc,       /* DSPF_RGB555 */
-     Sop_argb8565_SKto_Dacc        /* DSPF_ARGB8565 */
+     Sop_argb8565_SKto_Dacc,       /* DSPF_ARGB8565 */
+     Sop_avyu_SKto_Dacc,           /* DSPF_AVYU */
+     Sop_vyu_SKto_Dacc             /* DSPF_VYU */
 };
 
 /********************************* Sop_PFI_to_Dacc ****************************/
@@ -3115,6 +3396,50 @@ static void Sop_ayuv_to_Dacc( GenefxStat
      }
 }
 
+static void Sop_avyu_to_Dacc( GenefxState *gfxs )
+{
+     int                w = gfxs->length;
+     GenefxAccumulator *D = gfxs->Dacc;
+     u32               *S = gfxs->Sop[0];
+
+     while (w--) {
+          u32 s = *S++;
+
+          D->YUV.a = (s >> 24);
+          D->YUV.v = (s >> 16) & 0xff;
+          D->YUV.y = (s >>  8) & 0xff;
+          D->YUV.u = (s      ) & 0xff;
+
+          D++;
+     }
+}
+
+static void Sop_vyu_to_Dacc( GenefxState *gfxs )
+{
+     int                w = gfxs->length + 1;
+
+     GenefxAccumulator *D = gfxs->Dacc;
+     const u8          *S = gfxs->Sop[0];
+
+     while (--w) {
+
+#ifdef WORDS_BIGENDIAN
+          D->YUV.a = 0xff;
+          D->YUV.v = S[0];
+          D->YUV.y = S[1];
+          D->YUV.u = S[2];
+#else
+          D->YUV.a = 0xff;
+          D->YUV.v = S[2];
+          D->YUV.y = S[1];
+          D->YUV.u = S[0];
+#endif
+
+          S += 3;
+          D++;
+     }
+}
+
 static GenefxFunc Sop_PFI_to_Dacc[DFB_NUM_PIXELFORMATS] = {
      Sop_argb1555_to_Dacc,         /* DSPF_ARGB1555 */
      Sop_rgb16_to_Dacc,            /* DSPF_RGB16 */
@@ -3144,7 +3469,9 @@ static GenefxFunc Sop_PFI_to_Dacc[DFB_NU
      NULL,                         /* DSPF_LUT2 */
      Sop_xrgb4444_to_Dacc,         /* DSPF_RGB444 */
      Sop_xrgb1555_to_Dacc,         /* DSPF_RGB555 */
-     Sop_argb8565_to_Dacc          /* DSPF_ARGB8565 */
+     Sop_argb8565_to_Dacc,         /* DSPF_ARGB8565 */
+     Sop_avyu_to_Dacc,             /* DSPF_AVYU */
+     Sop_vyu_to_Dacc               /* DSPF_VYU */
 };
 
 /********************************* Sop_PFI_Kto_Dacc ***************************/
@@ -3556,6 +3883,66 @@ static void Sop_alut44_Kto_Dacc( GenefxS
      }
 }
 
+static void Sop_avyu_Kto_Dacc( GenefxState *gfxs )
+{
+     int l = gfxs->length;
+     u32 *S = gfxs->Sop[0];
+     GenefxAccumulator *D = gfxs->Dacc;
+     u32 Skey = gfxs->Skey;
+
+     while (l--) {
+          u32 s = *S++;
+
+          if ((s & 0x00ffffff) != Skey) {
+               D->YUV.a = (s & 0xff000000) >> 24;
+               D->YUV.v = (s & 0x00ff0000) >> 16;
+               D->YUV.y = (s & 0x0000ff00) >>  8;
+               D->YUV.u = (s & 0x000000ff) >>  0;
+          }
+          else
+               D->YUV.a = 0xf000;
+
+          D++;
+     }
+}
+
+static void Sop_vyu_Kto_Dacc( GenefxState *gfxs )
+{
+     int                w    = gfxs->length + 1;
+     GenefxAccumulator *D    = gfxs->Dacc;
+     u8                *S    = gfxs->Sop[0];
+     u32                Skey = gfxs->Skey;
+
+     while (--w) {
+
+#ifdef WORDS_BIGENDIAN
+          u32 s = S[0] << 16 | S[1] << 8 | S[2];
+#else
+          u32 s = S[2] << 16 | S[1] << 8 | S[0];
+#endif
+
+          if (Skey != s) {
+
+#ifdef WORDS_BIGENDIAN
+               D->YUV.a = 0xff;
+               D->YUV.v = S[0];
+               D->YUV.y = S[1];
+               D->YUV.u = S[2];
+#else
+               D->YUV.a = 0xff;
+               D->YUV.v = S[2];
+               D->YUV.y = S[1];
+               D->YUV.u = S[0];
+#endif
+          }
+          else
+               D->YUV.a = 0xF000;
+
+          S += 3;
+          D++;
+     }
+}
+
 static GenefxFunc Sop_PFI_Kto_Dacc[DFB_NUM_PIXELFORMATS] = {
      Sop_argb1555_Kto_Dacc,        /* DSPF_ARGB1555 */
      Sop_rgb16_Kto_Dacc,           /* DSPF_RGB16 */
@@ -3585,7 +3972,9 @@ static GenefxFunc Sop_PFI_Kto_Dacc[DFB_N
      NULL,                         /* DSPF_LUT2 */
      Sop_xrgb4444_Kto_Dacc,        /* DSPF_RGB444 */
      Sop_xrgb1555_Kto_Dacc,        /* DSPF_RGB555 */
-     Sop_argb8565_Kto_Dacc         /* DSPF_ARGB8565 */
+     Sop_argb8565_Kto_Dacc,        /* DSPF_ARGB8565 */
+     Sop_avyu_Kto_Dacc,            /* DSPF_AVYU */
+     Sop_vyu_Kto_Dacc              /* DSPF_VYU */
 };
 
 /********************************* Sacc_to_Aop_PFI ****************************/
@@ -4068,6 +4457,25 @@ static void Sacc_to_Aop_ayuv( GenefxStat
      }
 }
 
+static void Sacc_to_Aop_avyu( GenefxState *gfxs )
+{
+     int                w = gfxs->length;
+     GenefxAccumulator *S = gfxs->Sacc;
+     u32               *D = gfxs->Aop[0];
+
+     while (w--) {
+          if (!(S->YUV.a & 0xF000)) {
+               *D = PIXEL_AVYU( (S->YUV.a & 0xFF00) ? 0xFF : S->YUV.a,
+                                (S->YUV.y & 0xFF00) ? 0xFF : S->YUV.y,
+                                (S->YUV.u & 0xFF00) ? 0xFF : S->YUV.u,
+                                (S->YUV.v & 0xFF00) ? 0xFF : S->YUV.v );
+          }
+
+          D++;
+          S++;
+     }
+}
+
 static void Sacc_to_Aop_a4( GenefxState *gfxs )
 {
      int                w = gfxs->length>>1;
@@ -4096,6 +4504,28 @@ static void Sacc_to_Aop_a4( GenefxState 
      }
 }
 
+static void Sacc_to_Aop_vyu( GenefxState *gfxs )
+{
+     int                w = gfxs->length + 1;
+     GenefxAccumulator *S = gfxs->Sacc;
+     u8                *D = gfxs->Aop[0];
+
+     while (--w) {
+          if (!(S->YUV.a & 0xF000)) {
+               u32 pixel = PIXEL_VYU( (S->YUV.y & 0xFF00) ? 0xFF : S->YUV.y,
+                                      (S->YUV.u & 0xFF00) ? 0xFF : S->YUV.u,
+                                      (S->YUV.v & 0xFF00) ? 0xFF : S->YUV.v );
+
+               D[0] = (pixel >> 16) & 0xff;
+               D[1] = (pixel >>  8) & 0xff;
+               D[2] = (pixel >>  0) & 0xff;
+          }
+
+          D += 3;
+          S++;
+     }
+}
+
 static GenefxFunc Sacc_to_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Sacc_to_Aop_argb1555,         /* DSPF_ARGB1555 */
      Sacc_to_Aop_rgb16,            /* DSPF_RGB16 */
@@ -4125,7 +4555,9 @@ static GenefxFunc Sacc_to_Aop_PFI[DFB_NU
      NULL,                         /* DSPF_LUT2 */
      Sacc_to_Aop_xrgb4444,         /* DSPF_RGB444 */
      Sacc_to_Aop_xrgb1555,         /* DSPF_RGB555 */
-     Sacc_to_Aop_argb8565          /* DSPF_ARGB8565 */
+     Sacc_to_Aop_argb8565,         /* DSPF_ARGB8565 */
+     Sacc_to_Aop_avyu,             /* DSPF_AVYU */
+     Sacc_to_Aop_vyu               /* DSPF_VYU */
 };
 
 /********************************* Sacc_Sto_Aop_PFI ***************************/
@@ -4685,6 +5117,55 @@ static void Sacc_Sto_Aop_ayuv( GenefxSta
      }
 }
 
+static void Sacc_Sto_Aop_avyu( GenefxState *gfxs )
+{
+     int                w     = gfxs->length;
+     int                i     = gfxs->Xphase;
+     GenefxAccumulator *Sacc  = gfxs->Sacc;
+     u32               *D     = gfxs->Aop[0];
+     int                SperD = gfxs->SperD;
+
+     while (w--) {
+          GenefxAccumulator *S = &Sacc[i>>16];
+
+          if (!(S->YUV.a & 0xF000)) {
+               *D = PIXEL_AVYU( (S->YUV.a & 0xFF00) ? 0xFF : S->YUV.a,
+                                (S->YUV.y & 0xFF00) ? 0xFF : S->YUV.y,
+                                (S->YUV.u & 0xFF00) ? 0xFF : S->YUV.u,
+                                (S->YUV.v & 0xFF00) ? 0xFF : S->YUV.v );
+          }
+
+          D++;
+          i += SperD;
+     }
+}
+
+static void Sacc_Sto_Aop_vyu( GenefxState *gfxs )
+{
+     int                w     = gfxs->length;
+     int                i     = gfxs->Xphase;
+     GenefxAccumulator *Sacc  = gfxs->Sacc;
+     u8                *D     = gfxs->Aop[0];
+     int                SperD = gfxs->SperD;
+
+     while (w--) {
+          GenefxAccumulator *S = &Sacc[i>>16];
+
+          if (!(S->YUV.a & 0xF000)) {
+               u32 pixel = PIXEL_VYU( (S->YUV.y & 0xFF00) ? 0xFF : S->YUV.y,
+                                      (S->YUV.u & 0xFF00) ? 0xFF : S->YUV.u,
+                                      (S->YUV.v & 0xFF00) ? 0xFF : S->YUV.v );
+
+               D[0] = (pixel >> 16) & 0xff;
+               D[1] = (pixel >>  8) & 0xff;
+               D[2] = (pixel >>  0) & 0xff;
+          }
+
+          D += 3;
+          i += SperD;
+     }
+}
+
 
 static GenefxFunc Sacc_Sto_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Sacc_Sto_Aop_argb1555,        /* DSPF_ARGB1555 */
@@ -4715,7 +5196,9 @@ static GenefxFunc Sacc_Sto_Aop_PFI[DFB_N
      NULL,                         /* DSPF_LUT2 */
      Sacc_Sto_Aop_xrgb4444,        /* DSPF_RGB444 */
      Sacc_Sto_Aop_xrgb1555,        /* DSPF_RGB555 */
-     Sacc_Sto_Aop_argb8565         /* DSPF_ARGB8565 */
+     Sacc_Sto_Aop_argb8565,        /* DSPF_ARGB8565 */
+     Sacc_Sto_Aop_avyu,            /* DSPF_AVYU */
+     Sacc_Sto_Aop_vyu              /* DSPF_VYU */
 };
 
 /********************************* Sacc_toK_Aop_PFI ***************************/
@@ -5063,6 +5546,57 @@ static void Sacc_toK_Aop_alut44( GenefxS
      }
 }
 
+static void Sacc_toK_Aop_avyu( GenefxState *gfxs )
+{
+     int                w = gfxs->length + 1;
+     GenefxAccumulator *S = gfxs->Sacc;
+     u32               *D = gfxs->Aop[0];
+     u32                Dkey = gfxs->Dkey;
+
+     while (--w) {
+
+       if (!(S->YUV.a & 0xF000)
+           && (*D & 0x00ffffff) == Dkey)
+            *D = PIXEL_AVYU( (S->YUV.a & 0xff00) ? 0xff : S->YUV.a,
+                             (S->YUV.y & 0xff00) ? 0xff : S->YUV.y,
+                             (S->YUV.u & 0xff00) ? 0xff : S->YUV.u,
+                             (S->YUV.v & 0xff00) ? 0xff : S->YUV.v );
+
+          S++;
+          D++;
+     }
+}
+
+static void Sacc_toK_Aop_vyu( GenefxState *gfxs )
+{
+     int                w = gfxs->length + 1;
+     GenefxAccumulator *S = gfxs->Sacc;
+     u8                *D = gfxs->Aop[0];
+     u32                Dkey = gfxs->Dkey;
+
+     while (--w) {
+
+#ifdef WORDS_BIGENDIAN
+          u32 d = D[0] << 16 | D[1] << 8 | D[2];
+#else
+          u32 d = D[2] << 16 | D[1] << 8 | D[0];
+#endif
+
+          if (!(S->YUV.a & 0xF000) && Dkey == d) {
+               u32 pixel = PIXEL_VYU( (S->YUV.y & 0xFF00) ? 0xFF : S->YUV.y,
+                                      (S->YUV.u & 0xFF00) ? 0xFF : S->YUV.u,
+                                      (S->YUV.v & 0xFF00) ? 0xFF : S->YUV.v );
+
+               D[0] = (pixel >> 16) & 0xff;
+               D[1] = (pixel >>  8) & 0xff;
+               D[2] = (pixel >>  0) & 0xff;
+          }
+
+          D += 3;
+          S++;
+     }
+}
+
 static GenefxFunc Sacc_toK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Sacc_toK_Aop_argb1555,        /* DSPF_ARGB1555 */
      Sacc_toK_Aop_rgb16,           /* DSPF_RGB16 */
@@ -5092,7 +5626,9 @@ static GenefxFunc Sacc_toK_Aop_PFI[DFB_N
      NULL,                         /* DSPF_LUT2 */
      Sacc_toK_Aop_xrgb4444,        /* DSPF_RGB444 */
      Sacc_toK_Aop_xrgb1555,        /* DSPF_RGB555 */
-     Sacc_toK_Aop_argb8565         /* DSPF_ARGB8565 */
+     Sacc_toK_Aop_argb8565,        /* DSPF_ARGB8565 */
+     Sacc_toK_Aop_avyu,            /* DSPF_AVYU */
+     Sacc_toK_Aop_vyu              /* DSPF_VYU */
 };
 
 /********************************* Sacc_StoK_Aop_PFI **************************/
@@ -5137,6 +5673,62 @@ static void Sacc_StoK_Aop_argb8565( Gene
      }
 }
 
+static void Sacc_StoK_Aop_avyu( GenefxState *gfxs )
+{
+     int l = gfxs->length;
+     int i = gfxs->Xphase;
+     int SperD = gfxs->SperD;
+     GenefxAccumulator *Sacc = gfxs->Sacc;
+     u32 *D = gfxs->Aop[0];
+     u32 Dkey = gfxs->Dkey;
+
+     while (l--) {
+          GenefxAccumulator *S = &Sacc[i>>16];
+
+          if (!(S->YUV.a & 0xF000) && (*D & 0x00ffffff) == Dkey)
+               *D = PIXEL_AYUV( (S->YUV.a & 0xff00) ? 0xff : S->YUV.a,
+                                (S->YUV.y & 0xff00) ? 0xff : S->YUV.y,
+                                (S->YUV.u & 0xff00) ? 0xff : S->YUV.u,
+                                (S->YUV.v & 0xff00) ? 0xff : S->YUV.v );
+
+          D++;
+          i += SperD;
+     }
+}
+
+static void Sacc_StoK_Aop_vyu( GenefxState *gfxs )
+{
+     int                w     = gfxs->length + 1;
+     int                i     = gfxs->Xphase;
+     int                SperD = gfxs->Xphase;
+     GenefxAccumulator *Sacc  = gfxs->Sacc;
+     u8                *D     = gfxs->Aop[0];
+     u32                Dkey  = gfxs->Dkey;
+
+     while (--w) {
+          GenefxAccumulator *S = &Sacc[i>>16];
+
+#ifdef WORDS_BIGENDIAN
+          u32 d = D[0] << 16 | D[1] << 8 | D[2];
+#else
+          u32 d = D[2] << 16 | D[1] << 8 | D[0];
+#endif
+
+          if (!(S->YUV.a & 0xF000) && Dkey == d) {
+               u32 pixel = PIXEL_VYU( (S->YUV.y & 0xFF00) ? 0xFF : S->YUV.y,
+                                      (S->YUV.u & 0xFF00) ? 0xFF : S->YUV.u,
+                                      (S->YUV.v & 0xFF00) ? 0xFF : S->YUV.v );
+
+               D[0] = (pixel >> 16) & 0xff;
+               D[1] = (pixel >>  8) & 0xff;
+               D[2] = (pixel >>  0) & 0xff;
+          }
+
+          D += 3;
+          i += SperD;
+     }
+}
+
 static GenefxFunc Sacc_StoK_Aop_PFI[DFB_NUM_PIXELFORMATS] = {
      Sacc_StoK_Aop_argb1555,       /* DSPF_ARGB1555 */
      Sacc_StoK_Aop_rgb16,          /* DSPF_RGB16 */
@@ -5166,7 +5758,9 @@ static GenefxFunc Sacc_StoK_Aop_PFI[DFB_
      NULL,                         /* DSPF_LUT2 */
      Sacc_StoK_Aop_xrgb4444,       /* DSPF_RGB444 */
      Sacc_StoK_Aop_xrgb1555,       /* DSPF_RGB555 */
-     Sacc_StoK_Aop_argb8565        /* DSPF_ARGB8565 */
+     Sacc_StoK_Aop_argb8565,       /* DSPF_ARGB8565 */
+     Sacc_StoK_Aop_avyu,           /* DSPF_AVYU */
+     Sacc_StoK_Aop_vyu             /* DSPF_VYU */
 };
 
 /************** Bop_a8_set_alphapixel_Aop_PFI *********************************/
@@ -5455,6 +6049,63 @@ static void Bop_a8_set_alphapixel_Aop_rg
 #undef SET_PIXEL
 }
 
+static void Bop_a8_set_alphapixel_Aop_vyu( GenefxState *gfxs )
+{
+     int  w     = gfxs->length;
+     u8  *S     = gfxs->Bop[0];
+     u8  *D     = gfxs->Aop[0];
+     u8   YCop  = gfxs->YCop;
+     u8   CbCop = gfxs->CbCop;
+     u8   CrCop = gfxs->CrCop;
+
+#ifdef WORDS_BIGENDIAN
+
+#define SET_PIXEL(d,y,cb,cr,a)\
+     switch (a) {\
+         case 0xff:\
+               d[0] = cr;\
+               d[1] = y;\
+               d[2] = cb;\
+          case 0: break;\
+          default: {\
+               register u16 s = a+1;\
+               d[0] = ((cr-d[0]) * s + (d[0] << 8)) >> 8;\
+               d[1] = ((y-d[1]) * s + (d[1] << 8)) >> 8;\
+               d[2] = ((cb-d[2]) * s + (d[2] << 8)) >> 8;\
+          }\
+     }
+#else
+
+#define SET_PIXEL(d,y,cb,cr,a)\
+     switch (a) {\
+         case 0xff:\
+               d[0] = cb;\
+               d[1] = y;\
+               d[2] = cr;\
+          case 0: break;\
+          default: {\
+               register u16 s = a+1;\
+               d[0] = ((cb-d[0]) * s + (d[0] << 8)) >> 8;\
+               d[1] = ((y-d[1]) * s + (d[1] << 8)) >> 8;\
+               d[2] = ((cr-d[2]) * s + (d[2] << 8)) >> 8;\
+          }\
+     }
+#endif
+
+     while (w>4) {
+          SET_PIXEL( D, YCop, CbCop, CrCop, *S ); D+=3; S++;
+          SET_PIXEL( D, YCop, CbCop, CrCop, *S ); D+=3; S++;
+          SET_PIXEL( D, YCop, CbCop, CrCop, *S ); D+=3; S++;
+          SET_PIXEL( D, YCop, CbCop, CrCop, *S ); D+=3; S++;
+          w-=4;
+     }
+     while (w--) {
+          SET_PIXEL( D, YCop, CbCop, CrCop, *S ); D+=3, S++;
+     }
+
+#undef SET_PIXEL
+}
+
 
 /* saturating alpha blend */
 
@@ -5755,7 +6406,9 @@ static GenefxFunc Bop_a8_set_alphapixel_
      NULL,                                        /* DSPF_LUT2 */
      NULL,                                        /* DSPF_ARGB444 */
      NULL,                                        /* DSPF_ARGB555 */
-     Bop_a8_set_alphapixel_Aop_argb8565           /* DSPF_ARGB8565 */
+     Bop_a8_set_alphapixel_Aop_argb8565,          /* DSPF_ARGB8565 */
+     Bop_a8_set_alphapixel_Aop_argb,              /* DSPF_AVYU */
+     Bop_a8_set_alphapixel_Aop_vyu                /* DSPF_VYU */
 };
 
 /************** Bop_a1_set_alphapixel_Aop_PFI *********************************/
@@ -6084,7 +6737,9 @@ static GenefxFunc Bop_a1_set_alphapixel_
      NULL,                                        /* DSPF_LUT2 */
      NULL,                                        /* DSPF_RGB444 */
      NULL,                                        /* DSPF_RGB555 */
-     Bop_a1_set_alphapixel_Aop_argb8565           /* DSPF_ARGB8565 */
+     Bop_a1_set_alphapixel_Aop_argb8565,          /* DSPF_ARGB8565 */
+     Bop_a1_set_alphapixel_Aop_argb,              /* DSPF_AVYU */
+     Bop_a1_set_alphapixel_Aop_argb8565           /* DSPF_VYU */
 };
 
 
@@ -6860,7 +7515,9 @@ static GenefxFunc Bop_argb_blend_alphach
      NULL,                                             /* DSPF_LUT2 */
      NULL,                                             /* DSPF_RGB444 */
      NULL,                                             /* DSPF_RGB555 */
-     Bop_argb_blend_alphachannel_src_invsrc_Aop_argb8565  /* DSPF_ARGB8565 */
+     Bop_argb_blend_alphachannel_src_invsrc_Aop_argb8565, /* DSPF_ARGB8565 */
+     NULL,                                             /* DSPF_AVYU */
+     NULL                                              /* DSPF_VYU */
 };
 
 /* A8/A1 to YCbCr */
@@ -7338,6 +7995,18 @@ bool gAcquire( CardState *state, DFBAcce
           case DSPF_RGB555:
                gfxs->Cop = PIXEL_RGB555( color.r, color.g, color.b );
                break;
+          case DSPF_AVYU:
+               RGB_TO_YCBCR( color.r, color.g, color.b,
+                             gfxs->YCop, gfxs->CbCop, gfxs->CrCop );
+               gfxs->Cop = PIXEL_AVYU( color.a, gfxs->YCop, gfxs->CbCop, gfxs->CrCop );
+               dst_ycbcr = true;
+               break;
+          case DSPF_VYU:
+               RGB_TO_YCBCR( color.r, color.g, color.b,
+                             gfxs->YCop, gfxs->CbCop, gfxs->CrCop );
+               gfxs->Cop = PIXEL_VYU( gfxs->YCop, gfxs->CbCop, gfxs->CrCop );
+               dst_ycbcr = true;
+               break;
           default:
                D_ONCE("unsupported destination format");
                return false;
@@ -7385,6 +8054,8 @@ bool gAcquire( CardState *state, DFBAcce
                case DSPF_YUY2:
                case DSPF_UYVY:
                case DSPF_AYUV:
+               case DSPF_AVYU:
+               case DSPF_VYU:
                     if (dst_ycbcr) {
                          if (state->blittingflags & (DSBLIT_COLORIZE     |
                                                      DSBLIT_SRC_PREMULTCOLOR))
Index: DirectFB-1.0.1/src/idirectfb.c
===================================================================
--- DirectFB-1.0.1.orig/src/idirectfb.c	2007-09-24 14:34:25.080619152 +0100
+++ DirectFB-1.0.1/src/idirectfb.c	2007-09-24 14:35:09.555855173 +0100
@@ -473,6 +473,7 @@ IDirectFB_CreateSurface( IDirectFB      
           case DSPF_ARGB2554:
           case DSPF_ARGB4444:
           case DSPF_AYUV:
+          case DSPF_AVYU:
           case DSPF_AiRGB:
           case DSPF_I420:
           case DSPF_LUT2:
@@ -489,6 +490,7 @@ IDirectFB_CreateSurface( IDirectFB      
           case DSPF_NV12:
           case DSPF_NV21:
           case DSPF_NV16:
+          case DSPF_VYU:
           case DSPF_RGB444:
           case DSPF_RGB555:
                break;
@@ -594,6 +596,7 @@ IDirectFB_CreateSurface( IDirectFB      
                               case DSPF_ARGB1555:
                               case DSPF_ARGB:
                               case DSPF_AYUV:
+                              case DSPF_AVYU:
                               case DSPF_AiRGB:
                                    window_caps |= DWCAPS_ALPHACHANNEL;
                                    break;
Index: DirectFB-1.0.1/src/misc/conf.c
===================================================================
--- DirectFB-1.0.1.orig/src/misc/conf.c	2007-09-24 14:34:25.080619152 +0100
+++ DirectFB-1.0.1/src/misc/conf.c	2007-09-24 14:35:09.559855466 +0100
@@ -187,6 +187,7 @@ static const FormatString format_strings
      { "ARGB4444", DSPF_ARGB4444 },
      { "ARGB6666", DSPF_ARGB6666 },
      { "ARGB8565", DSPF_ARGB8565 },
+     { "AVYU",     DSPF_AVYU     },
      { "AYUV",     DSPF_AYUV     },
      { "AiRGB",    DSPF_AiRGB    },
      { "I420",     DSPF_I420     },
@@ -203,6 +204,7 @@ static const FormatString format_strings
      { "RGB444",   DSPF_RGB444   },
      { "RGB555",   DSPF_RGB555   },
      { "UYVY",     DSPF_UYVY     },
+     { "VYU",      DSPF_VYU      },
      { "YUY2",     DSPF_YUY2     },
      { "YV12",     DSPF_YV12     },
 };
Index: DirectFB-1.0.1/src/misc/gfx_util.c
===================================================================
--- DirectFB-1.0.1.orig/src/misc/gfx_util.c	2007-09-24 14:34:25.080619152 +0100
+++ DirectFB-1.0.1/src/misc/gfx_util.c	2007-09-24 14:45:01.992850181 +0100
@@ -336,6 +336,38 @@ static void write_argb_span (u32 *src, u
                }
                break;
 
+          case DSPF_AVYU:
+               for (i = 0; i < len; i++) {
+                    u32 a, y, u, v;
+
+                    RGB_TO_YCBCR( (src[i] >> 16) & 0xff,
+                                  (src[i] >>  8) & 0xff,
+                                  (src[i]      ) & 0xff, y, u, v );
+                    a = (src[i] >> 24) & 0xff;
+
+                    ((u32*)d)[i] = PIXEL_AVYU( a, y, u, v );
+               }
+               break;
+
+          case DSPF_VYU:
+               for (i = 0, j = -1; i < len; i++) {
+                    u32 y, u, v;
+
+                    RGB_TO_YCBCR( (src[i] >> 16) & 0xff,
+                                  (src[i] >>  8) & 0xff,
+                                  (src[i]      ) & 0xff, y, u, v );
+#ifdef WORDS_BIGENDIAN
+                    d[++j] = v;
+                    d[++j] = y;
+                    d[++j] = u;
+#else
+                    d[++j] = u;
+                    d[++j] = y;
+                    d[++j] = v;
+#endif
+               }
+               break;
+
           case DSPF_YV12:
           case DSPF_I420:
                d1 = dst[1];
Index: DirectFB-1.0.1/wm/default/default.c
===================================================================
--- DirectFB-1.0.1.orig/wm/default/default.c	2007-09-24 14:34:25.084619443 +0100
+++ DirectFB-1.0.1/wm/default/default.c	2007-09-24 14:35:09.559855466 +0100
@@ -386,6 +386,7 @@ window_at_pointer( CoreWindowStack *stac
                                         break;
                                    case DSPF_ARGB:
                                    case DSPF_AYUV:
+                                   case DSPF_AVYU:
                                         alpha = *(u32*)(data + 4 * wx + pitch * wy) >> 24;
                                         break;
                                    case DSPF_ARGB8565:
Index: DirectFB-1.0.1/gfxdrivers/Makefile.am
===================================================================
--- DirectFB-1.0.1.orig/gfxdrivers/Makefile.am	2007-08-30 14:02:38.000000000 +0100
+++ DirectFB-1.0.1/gfxdrivers/Makefile.am	2007-08-30 14:02:44.000000000 +0100
@@ -24,6 +24,12 @@
 MATROX_DIR =
 endif
 
+if GFX_STGFX
+STGFX_DIR = stgfx
+else
+STGFX_DIR =
+endif
+
 if GFX_TDFX
 TDFX_DIR = tdfx
 else
@@ -90,6 +96,7 @@
 UNICHROME_DIR =
 endif
 
+
 SUBDIRS = \
 	$(ATI_DIR)	\
 	$(RADEON_DIR)	\
@@ -101,6 +108,7 @@
 	$(NEOMAGIC_DIR)	\
 	$(SAVAGE_DIR)	\
 	$(SIS315_DIR)	\
+	$(STGFX_DIR)	\
 	$(I810_DIR)	\
 	$(I830_DIR)	\
 	$(CLE266_DIR)	\
Index: DirectFB-1.0.1/gfxdrivers/stgfx/Makefile.am
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ DirectFB-1.0.1/gfxdrivers/stgfx/Makefile.am	2007-08-30 14:07:33.000000000 +0100
@@ -0,0 +1,31 @@
+## Makefile.am for DirectFB/gfxdrivers/stgfx
+
+INCLUDES = \
+	-I$(top_srcdir)/include \
+	-I$(top_builddir)/lib   \
+	-I$(top_srcdir)/lib     \
+	-I$(top_srcdir)/src	\
+	-I$(top_srcdir)/systems
+
+stgfx_LTLIBRARIES = libdirectfb_stgfx.la
+
+if BUILD_STATIC
+stgfx_DATA = $(stgfx_LTLIBRARIES:.la=.o)
+endif
+
+stgfxdir = $(MODULEDIR)/gfxdrivers
+
+libdirectfb_stgfx_la_SOURCES =	\
+	stgfx.c
+
+libdirectfb_stgfx_la_LDFLAGS = \
+        -export-dynamic		\
+	-avoid-version		\
+        $(DFB_LDFLAGS)
+
+libdirectfb_stgfx_la_LIBADD = \
+	$(top_builddir)/lib/direct/libdirect.la \
+	$(top_builddir)/src/libdirectfb.la
+
+
+include $(top_srcdir)/rules/libobject.make
Index: DirectFB-1.0.1/configure.in
===================================================================
--- DirectFB-1.0.1.orig/configure.in	2007-08-30 14:02:42.000000000 +0100
+++ DirectFB-1.0.1/configure.in	2007-08-30 14:02:44.000000000 +0100
@@ -861,6 +861,7 @@
 tdfx=no
 savage=no
 sis315=no
+stgfx=no
 
 if test "$have_linux" = "yes"; then
 
@@ -872,7 +873,7 @@
 [                            Possible gfxdrivers are: ]
 [                            ati128, cle266, cyber5k, i810, i830, mach64, matrox,]
 [                            neomagic, nsc, nvidia, radeon, savage,]
-[                            sis315, tdfx, unichrome], gfxdrivers="$withval",[gfxdrivers="all"])
+[                            sis315, stgfx, tdfx, unichrome], gfxdrivers="$withval",[gfxdrivers="all"])
 
 if test "$gfxdrivers" = "all"; then
   checkfor_ati128=yes
@@ -888,6 +889,7 @@
   checkfor_radeon=yes 
   checkfor_savage=yes
   checkfor_sis315=yes
+  checkfor_stgfx=yes
   checkfor_tdfx=yes
   checkfor_unichrome=yes
   AC_MSG_RESULT(all)
@@ -936,6 +938,9 @@
           sis315)
                   checkfor_sis315=yes
                   ;;
+          stgfx)
+                  checkfor_stgfx=yes
+                  ;;
           tdfx)
                   checkfor_tdfx=yes
                   ;;
@@ -968,6 +973,10 @@
   matrox=yes
 fi
 
+if test "$checkfor_stgfx" = "yes" ; then
+  stgfx=yes
+fi
+
 if test "$checkfor_tdfx" = "yes"; then
   tdfx=yes
 fi
@@ -1012,7 +1021,6 @@
   unichrome=yes
 fi
 
-
 # lets check for input driver
 
 checkfor_dbox2remote=no
@@ -1309,6 +1317,7 @@
 AM_CONDITIONAL(GFX_RADEON, test "$radeon" = "yes")
 AM_CONDITIONAL(GFX_SAVAGE, test "$savage" = "yes")
 AM_CONDITIONAL(GFX_SIS315, test "$sis315" = "yes")
+AM_CONDITIONAL(GFX_STGFX, test "$stgfx" = "yes")
 AM_CONDITIONAL(GFX_TDFX, test "$tdfx" = "yes")
 AM_CONDITIONAL(GFX_UNICHROME, test "$unichrome" = "yes")
 
@@ -1474,6 +1483,7 @@
 gfxdrivers/radeon/Makefile
 gfxdrivers/savage/Makefile
 gfxdrivers/sis315/Makefile
+gfxdrivers/stgfx/Makefile
 gfxdrivers/tdfx/Makefile
 gfxdrivers/unichrome/Makefile
 
@@ -1586,6 +1596,7 @@
   nVidia                    $nvidia
   S3 Savage                 $savage
   SiS 315                   $sis315
+  STM Gamma                 $stgfx
   TVIA CyberPro             $cyber5k
   VIA CLE266                $cle266
   VIA UniChrome             $unichrome
Add the ST accelerated graphics driver source for DirectFB 1.0.1.

Signed of by: Stephen Gallimore <Stephen.Gallimore@st.com>

Index: DirectFB-1.0.1/gfxdrivers/stgfx/stgfx.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ DirectFB-1.0.1/gfxdrivers/stgfx/stgfx.c	2007-09-24 14:52:44.903568743 +0100
@@ -0,0 +1,1473 @@
+/*
+   (c) Copyright 2003, 2007  STMicroelectronics Ltd.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+
+#include <linux/fb.h>
+#include <linux/stmfb.h>
+
+#include <directfb.h>
+#include <dfb_types.h>
+
+#include <core/coredefs.h>
+#include <core/coretypes.h>
+
+#include <core/state.h>
+#include <core/gfxcard.h>
+#include <core/surfaces.h>
+#include <core/system.h>
+#include <core/palette.h>
+#include <core/layers.h>
+
+#include <fbdev/fbdev.h>
+
+#include <gfx/convert.h>
+#include <gfx/util.h>
+
+#include <core/graphics_driver.h>
+
+#include "stgfx.h"
+
+DFB_GRAPHICS_DRIVER( stgfx );
+
+static const DFBSurfaceDrawingFlags STGFX_VALID_DRAWINGFLAGS_GAMMA = (
+  DSDRAW_BLEND           |
+  DSDRAW_DST_COLORKEY    |
+  DSDRAW_SRC_PREMULTIPLY);
+
+static const DFBSurfaceDrawingFlags STGFX_VALID_DRAWINGFLAGS_BDISP = (
+  DSDRAW_BLEND           |
+  DSDRAW_XOR             |
+  DSDRAW_SRC_PREMULTIPLY);
+
+static DFBSurfaceDrawingFlags STGFX_VALID_DRAWINGFLAGS;
+
+static const DFBAccelerationMask STGFX_VALID_DRAWINGFUNCTIONS = DFXL_FILLRECTANGLE |
+                                                                DFXL_DRAWRECTANGLE;
+
+static const DFBSurfaceDrawingFlags STGFX_VALID_BLITTINGFLAGS_GAMMA = (
+  DSBLIT_INDEX_TRANSLATION  |
+  DSBLIT_SRC_COLORKEY       |
+  DSBLIT_DST_COLORKEY       |
+  DSBLIT_BLEND_COLORALPHA   |
+  DSBLIT_BLEND_ALPHACHANNEL |
+  DSBLIT_SRC_PREMULTIPLY    |
+  DSBLIT_SRC_PREMULTCOLOR);
+
+static const DFBSurfaceDrawingFlags STGFX_VALID_BLITTINGFLAGS_BDISP = (
+  DSBLIT_INDEX_TRANSLATION  |
+  DSBLIT_SRC_COLORKEY       |
+  DSBLIT_BLEND_COLORALPHA   |
+  DSBLIT_BLEND_ALPHACHANNEL |
+  DSBLIT_SRC_PREMULTIPLY    |
+  DSBLIT_XOR                |
+  DSBLIT_COLORIZE           |
+  DSBLIT_SRC_PREMULTCOLOR);
+
+
+static DFBSurfaceDrawingFlags STGFX_VALID_BLITTINGFLAGS;
+
+static const DFBAccelerationMask STGFX_VALID_BLITTINGFUNCTIONS = (DFXL_BLIT | DFXL_STRETCHBLIT);
+
+static int stgfx_accel_type;
+
+static bool stgfxCheckPixelFormat(DFBSurfacePixelFormat dfbFmt, bool bSrc, bool *hasAlpha, bool *isClut);
+static unsigned long stgfxSetPixelFormat(DFBSurfacePixelFormat dfbFmt) __attribute__((pure));
+/* local typedefs */
+
+/* Structure for storing information about device state*/
+typedef struct {
+  unsigned long srcPitch;
+  unsigned long srcOffset;
+  SURF_FMT      srcFormat;
+  unsigned long dstPitch;
+  unsigned long dstOffset;
+  SURF_FMT      dstFormat;
+  unsigned long blitColour;
+  unsigned long drawColour;
+  unsigned long srcColourKey;
+  unsigned long dstColourKey;
+  unsigned long globalAlpha;
+
+  DFBSurfaceBlendFunction srcBlendFunc;
+  DFBSurfaceBlendFunction dstBlendFunc;
+
+  DFBSurfaceDrawingFlags  drawingFlags;
+  DFBSurfaceBlittingFlags blittingFlags;
+
+  CorePalette   *palette;
+
+  bool           bBlendFromColorAlpha;
+  bool           bBlendFromSrcAlpha;
+  bool           bSrcPremultiply;
+  bool           bPremultColor;
+  bool           bNeedCLUTReload;
+} STGFXDeviceData;
+
+
+/*****************************************************************/
+/* Fill in the command data that is common to all draw functions */
+/*****************************************************************/
+static bool stgfxDraw
+(
+  STGFXDriverData*  pDrv,
+  STGFXDeviceData*  pDev,
+  DFBRectangle*     rect,
+  STMFBIO_BLT_DATA   *pBltData
+)
+{
+  pBltData->dstOffset  = pDev->dstOffset;
+  pBltData->dstPitch   = pDev->dstPitch;
+
+  pBltData->dstFormat  = pDev->dstFormat;
+
+  pBltData->dst_left   = (unsigned short)rect->x;
+  pBltData->dst_top    = (unsigned short)rect->y;
+  pBltData->dst_right  = (unsigned short)(rect->x + rect->w);
+  pBltData->dst_bottom = (unsigned short)(rect->y + rect->h);
+  pBltData->colour     = pDev->drawColour;
+
+  if (pDev->drawingFlags & DSDRAW_DST_COLORKEY)
+  {
+    pBltData->ulFlags   |= BLT_OP_FLAGS_DST_COLOR_KEY;
+    pBltData->colourKey  = pDev->dstColourKey;
+  }
+
+  if (pDev->drawingFlags & DSDRAW_BLEND)
+  {
+    if(pDev->srcBlendFunc == DSBF_ZERO && pDev->dstBlendFunc == DSBF_ZERO)
+    {
+      /*
+       * This is a clear, just fill with 0. Set the source format to the
+       * dest format to get a fast fill.
+       */
+      pBltData->colour    = 0;
+      pBltData->srcFormat = pBltData->dstFormat;
+    }
+    else if(pDev->srcBlendFunc == DSBF_ONE && pDev->dstBlendFunc == DSBF_ZERO)
+    {
+      /*
+       * This is just a src fill, but the colour is in ARGB8888 not the
+       * destination surface format. The hardware will convert for us.
+       */
+      pBltData->srcFormat = SURF_ARGB8888;
+    }
+    else if(pDev->srcBlendFunc == DSBF_ZERO && pDev->dstBlendFunc == DSBF_ONE)
+    {
+      /*
+       * This leaves the destination as is, i.e. a nop, because we do not
+       * support destination pre-multiplication.
+       */
+      return true;
+    }
+    else
+    {
+      /*
+       * This must be
+       *    (1) src func = 1.0  , dest func = 1-src alpha
+       * or (2) src func = src alpha, dest func = 1-src alpha
+       *
+       * because of the restrictions imposed in check state. We can
+       * only support (2) when the destination format has no alpha channel.
+       * This is because the hardware always calculates the destination alpha
+       * as Asrc + Adst*(1-Asrc), which is correct for (1) but for (2) we
+       * would require Asrc*Asrc + Adst*(1-Asrc).
+       */
+      pBltData->ulFlags    |= (pDev->srcBlendFunc == DSBF_SRCALPHA) ? BLT_OP_FLAGS_BLEND_SRC_ALPHA : BLT_OP_FLAGS_BLEND_SRC_ALPHA_PREMULT;
+      pBltData->ulFlags    |= BLT_OP_FLAGS_BLEND_DST_MEMORY;
+      pBltData->srcFormat   = SURF_ARGB8888;
+    }
+  }
+  else
+  {
+    if(pDev->drawingFlags & DSDRAW_XOR)
+      pBltData->ulFlags |= BLT_OP_FLAGS_XOR;
+
+    if(pBltData->dstFormat == SURF_YCBCR422R
+       || pBltData->dstFormat == SURF_ACRYCB8888
+       || pBltData->dstFormat == SURF_CRYCB888)
+    {
+      /*
+       * For 422R we let the hardware do the conversion, as direct fast fill
+       * in 422R has problems (probably due to two pixels being mixed up in a
+       * 32bit word).
+       */
+      pBltData->srcFormat = SURF_ARGB8888;
+    }
+    else
+    {
+      /*
+       * Simple fast fill, the colour is already in the destination colour format
+       */
+      pBltData->srcFormat = pBltData->dstFormat;
+    }
+  }
+
+  if (ioctl(pDrv->fd, STMFBIO_BLT, pBltData ) < 0)
+    return false;
+
+  return true;
+}
+
+/*****************************************************************/
+/* Fill in the command data that is common to all blit functions */
+/*****************************************************************/
+static bool stgfxCommonBlitData
+(
+  STGFXDriverData*  pDrv,
+  STGFXDeviceData  *pDev,
+  STMFBIO_BLT_DATA *pBltData
+)
+{
+  bool set_premultcolor = true;
+  pBltData->operation = BLT_OP_COPY;
+
+  if (pDev->blittingFlags & DSBLIT_SRC_COLORKEY)
+  {
+    pBltData->ulFlags    |= BLT_OP_FLAGS_SRC_COLOR_KEY;
+    pBltData->colourKey   = pDev->srcColourKey;
+  }
+
+  if (pDev->blittingFlags & DSBLIT_DST_COLORKEY)
+  {
+    pBltData->ulFlags   |= BLT_OP_FLAGS_DST_COLOR_KEY;
+    pBltData->colourKey  = pDev->dstColourKey;
+  }
+
+  pBltData->srcOffset = pDev->srcOffset;
+  pBltData->srcPitch  = pDev->srcPitch;
+
+  pBltData->dstOffset = pDev->dstOffset;
+  pBltData->dstPitch  = pDev->dstPitch;
+
+  pBltData->srcFormat = pDev->srcFormat;
+  pBltData->dstFormat = pDev->dstFormat;
+
+  pBltData->colour      = pDev->blitColour;
+  pBltData->globalAlpha = pDev->globalAlpha;
+
+  if (pDev->bBlendFromColorAlpha & !pDev->bBlendFromSrcAlpha)
+  {
+    if(pDev->srcBlendFunc == DSBF_ZERO && pDev->dstBlendFunc == DSBF_ZERO)
+    {
+      /* This is a clear, just fill with 0 */
+      pBltData->operation   = BLT_OP_FILL;
+      pBltData->colour      = 0;
+      /*
+       * Change the source format to match the dest so we get a fast fill,
+       * the other source surface parameters are ignored.
+       */
+      pBltData->srcFormat = pBltData->dstFormat;
+      set_premultcolor = false;
+    }
+    else if(pDev->srcBlendFunc == DSBF_ZERO && pDev->dstBlendFunc == DSBF_ONE)
+    {
+      /*
+       * This leaves the destination as is, i.e. a nop, because we do not
+       * support destination pre-multiplication.
+       */
+      return false;
+    }
+    else if(pDev->srcBlendFunc == DSBF_ONE && pDev->dstBlendFunc == DSBF_ZERO)
+    {
+      /*
+       * This is a copy (blend with a destination of (0,0,0,0)) after
+       * premultiplication with the colour alpha channel.
+       */
+      pBltData->ulFlags |= BLT_OP_FLAGS_GLOBAL_ALPHA | BLT_OP_FLAGS_BLEND_SRC_ALPHA | BLT_OP_FLAGS_BLEND_DST_ZERO;
+
+      if(pDev->bPremultColor && !pDev->bSrcPremultiply)
+        set_premultcolor = false;
+    }
+    else
+    {
+      /*
+       * Both of the real support blend combinations end up being the same
+       * operation.
+       */
+      pBltData->ulFlags |= BLT_OP_FLAGS_GLOBAL_ALPHA | BLT_OP_FLAGS_BLEND_SRC_ALPHA | BLT_OP_FLAGS_BLEND_DST_MEMORY;
+
+      if(pDev->bPremultColor && !pDev->bSrcPremultiply && (pDev->srcBlendFunc != DSBF_SRCALPHA))
+        set_premultcolor = false;
+    }
+  }
+  else if (pDev->bBlendFromSrcAlpha)
+  {
+    if(pDev->srcBlendFunc == DSBF_ZERO && pDev->dstBlendFunc == DSBF_ZERO)
+    {
+      /* This is a clear, just fill with 0 */
+      pBltData->operation   = BLT_OP_FILL;
+      pBltData->colour      = 0;
+      /*
+       * Change the source format to match the dest so we get a fast fill,
+       * the other source surface parameters are ignored.
+       */
+      pBltData->srcFormat = pBltData->dstFormat;
+      set_premultcolor = false;
+    }
+    else if(pDev->srcBlendFunc == DSBF_ONE && pDev->dstBlendFunc == DSBF_ZERO)
+    {
+      pBltData->ulFlags |= BLT_OP_FLAGS_BLEND_DST_ZERO;
+      pBltData->ulFlags |= pDev->bSrcPremultiply ? BLT_OP_FLAGS_BLEND_SRC_ALPHA : BLT_OP_FLAGS_BLEND_SRC_ALPHA_PREMULT;
+      if(pDev->bBlendFromColorAlpha)
+      {
+        pBltData->ulFlags |= BLT_OP_FLAGS_GLOBAL_ALPHA;
+        if(pDev->bPremultColor && !pDev->bSrcPremultiply)
+          set_premultcolor = false;
+      }
+    }
+    else if(pDev->srcBlendFunc == DSBF_ZERO && pDev->dstBlendFunc == DSBF_ONE)
+    {
+      /*
+       * This leaves the destination as is, i.e. a nop, because we do not
+       * support destination pre-multiplication.
+       */
+      return false;
+    }
+    else if(pDev->srcBlendFunc == DSBF_ONE && pDev->dstBlendFunc == DSBF_INVSRCALPHA)
+    {
+      /*
+       * The flags look the wrong way about, but they specifiy if the source
+       * is _already_ pre-multiplied or not rather than the operation required.
+       */
+      pBltData->ulFlags |= BLT_OP_FLAGS_BLEND_DST_MEMORY;
+      pBltData->ulFlags |= pDev->bSrcPremultiply ? BLT_OP_FLAGS_BLEND_SRC_ALPHA : BLT_OP_FLAGS_BLEND_SRC_ALPHA_PREMULT;
+      if(pDev->bBlendFromColorAlpha)
+      {
+        pBltData->ulFlags |= BLT_OP_FLAGS_GLOBAL_ALPHA;
+        if(pDev->bPremultColor && !pDev->bSrcPremultiply)
+          set_premultcolor = false;
+      }
+    }
+    else
+    {
+      /*
+       * Must be srcBlendFunc == DSBF_SRCALPHA, dstBlendFunc == DSBF_INVSRCALPHA,
+       * premultiply off, dest no alpha channel. Note that we use the blend flag
+       * that normally enables pre-multiplication to effectively do the DSBF_SRCALPHA
+       * blend maths.
+       */
+      pBltData->ulFlags |= BLT_OP_FLAGS_BLEND_DST_MEMORY;
+      pBltData->ulFlags |= BLT_OP_FLAGS_BLEND_SRC_ALPHA;
+      if(pDev->bBlendFromColorAlpha)
+      {
+        pBltData->ulFlags |= BLT_OP_FLAGS_GLOBAL_ALPHA;
+      }
+    }
+  }
+  else
+  {
+    if(pDev->blittingFlags & DSBLIT_XOR)
+    {
+      pBltData->ulFlags |= BLT_OP_FLAGS_XOR;
+    }
+    else if(pDev->blittingFlags & DSBLIT_SRC_PREMULTIPLY)
+    {
+      /*
+       * This is a copy (blend with a destination of (0,0,0,0)) after
+       * premultiplication with the colour alpha channel.
+       */
+      pBltData->ulFlags |= (BLT_OP_FLAGS_BLEND_SRC_ALPHA | BLT_OP_FLAGS_BLEND_DST_ZERO);
+    }
+  }
+
+  if(pDev->blittingFlags & DSBLIT_COLORIZE)
+    pBltData->ulFlags |= BLT_OP_FLAGS_COLORIZE;
+
+  /*
+   * If DSBLIT_SRC_PREMULTCOLOR is set, but this hasn't been done as part of an
+   * alpha blend operation already, do it explicitly using the
+   * input matrix transformation on hardware that has this available.
+   */
+  if(set_premultcolor && (pDev->blittingFlags & DSBLIT_SRC_PREMULTCOLOR))
+    pBltData->ulFlags |= BLT_OP_FLAGS_PREMULT_COLOUR_ALPHA;
+
+  return true;
+}
+
+/*********************************************************************/
+/* Update palette and enable CLUT blit operation if required         */
+/*********************************************************************/
+static bool stgfxUpdatePalette
+(
+  STGFXDriverData*  pDrv,
+  STGFXDeviceData  *pDev,
+  STMFBIO_BLT_DATA *pBltData
+)
+{
+  if(pDev->palette && (pDev->blittingFlags != DSBLIT_INDEX_TRANSLATION))
+  {
+    if(pDev->bNeedCLUTReload)
+    {
+      STMFBIO_PALETTE lut;
+      int i;
+      bzero(&lut, sizeof(STMFBIO_PALETTE));
+
+      lut.numEntries = pDev->palette->num_entries;
+
+      for(i=0; i < lut.numEntries; i++)
+      {
+        DFBColor *color = &pDev->palette->entries[i];
+        /* Note that the alpha range for the lut is 0-128 (note not 127!!) */
+        lut.entries[i] = PIXEL_ARGB((color->a+1)/2, color->r, color->g, color->b);
+      }
+
+      if (ioctl(pDrv->fd, STMFBIO_SET_BLITTER_PALETTE, &lut ) < 0 )
+        return false;
+    }
+
+    pBltData->ulFlags |= BLT_OP_FLAGS_CLUT_ENABLE;
+  }
+
+  return true;
+}
+
+
+/*********************************************************************/
+/* Store the destination surface state in the device state structure */
+/*********************************************************************/
+static void stgfxSetDestination
+(
+  STGFXDeviceData*  pDev,
+  CardState*        pState
+)
+{
+  CoreSurface*    destSurf    = pState->destination;
+  SurfaceBuffer*  destBuffer;
+
+  if(destSurf == NULL)
+  {
+    pDev->dstFormat = SURF_NULL_PAD;
+    pDev->dstOffset = 0;
+    pDev->dstPitch  = 0;
+    return;
+  }
+
+  pDev->dstFormat = stgfxSetPixelFormat(destSurf->format);
+
+  destBuffer      = destSurf->back_buffer;
+  pDev->dstPitch  = (unsigned long)destBuffer->video.pitch;
+  pDev->dstOffset = (unsigned long)destBuffer->video.offset;
+}
+
+
+/**************************************************************/
+/* Set the source surface state in the device state structure */
+/**************************************************************/
+static void stgfxSetSource
+(
+  STGFXDriverData*  pDrv,
+  STGFXDeviceData*  pDev,
+  CardState*        pState
+)
+{
+  CoreSurface*    srcSurf   = pState->source;
+  SurfaceBuffer*  srcBuffer;
+
+  if(srcSurf == NULL)
+  {
+    pDev->srcFormat = SURF_NULL_PAD;
+    pDev->srcOffset = 0;
+    pDev->srcPitch  = 0;
+    return;
+  }
+
+  if(srcSurf->format == DSPF_LUT2 || srcSurf->format == DSPF_LUT8 || srcSurf->format == DSPF_ALUT44)
+  {
+    pDev->palette = srcSurf->palette;
+    pDev->bNeedCLUTReload = true;
+  }
+  else
+  {
+    pDev->palette = NULL;
+  }
+
+  pDev->srcFormat = stgfxSetPixelFormat(srcSurf->format);
+
+  srcBuffer       = srcSurf->front_buffer;
+  pDev->srcOffset = (unsigned long)srcBuffer->video.offset;
+  pDev->srcPitch  = (unsigned long)srcBuffer->video.pitch;
+}
+
+/******************************************************************************/
+/* Create a single int colour from the colour structure received from directFB*/
+/******************************************************************************/
+static void stgfxSetColour
+(
+  STGFXDeviceData*  pDev,
+  CardState*        pState
+)
+{
+unsigned int alpha  = (unsigned int)pState->color.a;
+unsigned int red    = (unsigned int)pState->color.r;
+unsigned int green  = (unsigned int)pState->color.g;
+unsigned int blue   = (unsigned int)pState->color.b;
+
+  pDev->blitColour = PIXEL_ARGB(alpha, red, green, blue);
+  /*
+   * Store the alpha for blended blits of non-alpha surfaces
+   */
+  pDev->globalAlpha = alpha;
+
+  if(pDev->drawingFlags & DSDRAW_SRC_PREMULTIPLY)
+  {
+    /*
+     * We do source alpha pre-multiplication now, rather in the hardware so
+     * we can support it regardless of the blend mode.
+     */
+    red   = (red  *(alpha+1)) >> 8;
+    green = (green*(alpha+1)) >> 8;
+    blue  = (blue *(alpha+1)) >> 8;
+  }
+
+  if (pDev->drawingFlags & DSDRAW_BLEND)
+  {
+    /*
+     * For blended fills we use ARGB8888, to get full alpha precision in the
+     * blend, the hardware does color conversion.
+     */
+    pDev->drawColour = PIXEL_ARGB(alpha, red, green, blue);
+    return;
+  }
+
+  switch (pState->destination->format)
+  {
+  case DSPF_ARGB1555:
+    pDev->drawColour = PIXEL_ARGB1555(alpha, red, green, blue);
+    break;
+
+  case DSPF_ARGB4444:
+    pDev->drawColour = PIXEL_ARGB4444(alpha, red, green, blue);
+    break;
+
+  case DSPF_RGB16:
+    pDev->drawColour = PIXEL_RGB16(red, green, blue);
+    break;
+
+  case DSPF_RGB24:
+    pDev->drawColour = PIXEL_RGB32(red, green, blue);
+    break;
+
+  case DSPF_ARGB8565:
+    pDev->drawColour = PIXEL_ARGB8565(alpha, red, green, blue);
+    break;
+
+  case DSPF_UYVY:
+  case DSPF_AVYU:
+  case DSPF_VYU:
+    /*
+     * Note we get the hardware to do the conversion from RGB to YUV
+     */
+  case DSPF_ARGB:
+    pDev->drawColour = PIXEL_ARGB(alpha, red, green, blue);
+    break;
+
+  case DSPF_LUT2:
+  case DSPF_LUT8:
+    pDev->drawColour = pState->color_index;
+    break;
+
+  case DSPF_ALUT44:
+    pDev->drawColour = (alpha & 0xF0) | (pState->color_index & 0x0F);
+    break;
+
+  case DSPF_A8:
+    pDev->drawColour = alpha;
+    break;
+
+  default:
+    D_ERROR("DirectFB/gfxdrivers/stgfx: Unexpected colour format\n");
+    return;
+  }
+}
+
+/*********************************************/
+/* Check that all graphics ops have completed*/
+/*********************************************/
+static DFBResult stgfxEngineSync
+(
+  void* drv,
+  void* dev
+)
+{
+  STGFXDriverData* pDrv = (STGFXDriverData*)drv;
+  if (ioctl(pDrv->fd, STMFBIO_SYNC_BLITTER, 0 ) < 0)
+  {
+    D_PERROR("DirectFB/gfxdrivers/stgfx: Sync Engine failed\n");
+    D_ERROR("DirectFB/gfxdrivers/stgfx: file descriptor = %d\n",pDrv->fd);
+  }
+
+  return DFB_OK;
+}
+
+/**************************************************************************/
+/* Check that the current state is ok for the operation indicated by accel*/
+/**************************************************************************/
+static void stgfxCheckState
+(
+  void*               drv,
+  void*               dev,
+  CardState*          state,
+  DFBAccelerationMask accel
+)
+{
+bool supportedBlend = false;
+bool srcHasAlpha    = false;
+bool dstHasAlpha    = false;
+bool srcIsClut      = false;
+bool dstIsClut      = false;
+bool canUseHWInputMatrix;
+
+
+  state->accel = 0;
+
+  /* Flag the blending maths we can support */
+  if (state->src_blend == DSBF_ZERO && state->dst_blend == DSBF_ZERO) /* Clear */
+    supportedBlend = true;
+
+  if (state->src_blend == DSBF_ONE && state->dst_blend == DSBF_ZERO) /* Copy */
+    supportedBlend = true;
+
+  if (state->src_blend == DSBF_ZERO && state->dst_blend == DSBF_ONE) /* Nop */
+    supportedBlend = true;
+
+  if (state->src_blend == DSBF_ONE && state->dst_blend == DSBF_INVSRCALPHA)
+    supportedBlend = true;
+
+  if (state->src_blend == DSBF_SRCALPHA && state->dst_blend == DSBF_INVSRCALPHA)
+    supportedBlend = true;
+
+  if(!stgfxCheckPixelFormat(state->destination->format, false, &dstHasAlpha, &dstIsClut))
+    return; /* unsupported destination format */
+
+  /* Check there are no other drawing flags than those that are supported */
+  if (!(state->drawingflags & ~STGFX_VALID_DRAWINGFLAGS))
+  {
+    if (state->drawingflags & DSDRAW_BLEND)
+    {
+      /*
+       * Cannot support blend and xor at the same time
+       */
+      if (state->drawingflags & DSDRAW_XOR)
+        goto blit_acceleration;
+
+      if(!supportedBlend || dstIsClut)
+      {
+        /*
+         * Don't allow blends to LUT surfaces, but we do allow fast fills in
+         * order to be able to do a "clear" to a specific index.
+         */
+        goto blit_acceleration;
+      }
+
+      if (dstHasAlpha && (state->src_blend == DSBF_SRCALPHA && state->dst_blend == DSBF_INVSRCALPHA))
+      {
+        /*
+         * src func = src alpha, dst func = 1-src alpha can only be accelerated
+         * when the destination does not have an alpha channel, becuase the
+         * correct calculation of the destination alpha cannot be acheived in
+         * the hardware. We go to the trouble of supporting it as the mode is
+         * used in the blended fill df_dok performance test.
+         */
+        goto blit_acceleration;
+
+      }
+    }
+
+    state->accel |= STGFX_VALID_DRAWINGFUNCTIONS;
+  }
+
+
+blit_acceleration:
+
+  if (!(state->blittingflags & ~STGFX_VALID_BLITTINGFLAGS))
+  {
+    if(!state->source)
+      goto exit; /* Cannot blit if there is no source surface */
+
+    canUseHWInputMatrix = (stgfx_accel_type == FB_ACCEL_ST_BDISP
+                           && ((state->source->format != DSPF_UYVY
+                                && state->destination->format != DSPF_UYVY)
+                               || state->source->format == state->destination->format)
+                           && ((state->source->format != DSPF_AVYU
+                                && state->destination->format != DSPF_AVYU)
+                               || state->source->format == state->destination->format)
+                           && ((state->source->format != DSPF_VYU
+                                && state->destination->format != DSPF_VYU)
+                               || state->source->format == state->destination->format)
+                           );
+
+    if((state->blittingflags & DSBLIT_COLORIZE) && !canUseHWInputMatrix)
+      goto exit;
+
+    /*
+     * Deal with a special case of LUT->LUT blits that do not go through
+     * a colour lookup, but instead do an index translation mapping. Note that
+     * we do not actually support anything other than a 1-1 mapping of the CLUT.
+     */
+    if (dstIsClut)
+    {
+      if( state->blittingflags == DSBLIT_INDEX_TRANSLATION &&
+          state->source && (state->source->format == state->destination->format) )
+      {
+        state->accel = DFXL_BLIT;
+      }
+      /*
+       * Note that blits are not supported to LUT destinations other than in
+       * the index translation case.
+       */
+      goto exit;
+    }
+
+    if((state->blittingflags & (DSBLIT_SRC_COLORKEY | DSBLIT_DST_COLORKEY)) == (DSBLIT_SRC_COLORKEY | DSBLIT_DST_COLORKEY))
+      goto exit; /* Cannot accelerate simultaneous source and destination colour keying */
+
+    if(!stgfxCheckPixelFormat(state->source->format, true, &srcHasAlpha, &srcIsClut))
+      goto exit; /* unsupported source pixel type */
+
+    if(state->blittingflags & DSBLIT_BLEND_ALPHACHANNEL)
+    {
+      if(!supportedBlend)
+        goto exit;
+
+      /*
+       * We cannot blend and XOR at the same time, what a silly idea
+       */
+      if(state->blittingflags & DSBLIT_XOR)
+        goto exit;
+
+      /*
+       * We cannot blend with a source of DSBF_RGB32 because the hardware cannot
+       * be made to ignore the top 8 bits and will use them as an alpha channel
+       */
+      if(state->source->format == DSPF_RGB32)
+        goto exit;
+
+      if(state->blittingflags & DSBLIT_BLEND_COLORALPHA)
+      {
+        /*
+         * If COLORALPHA is also specified then the constant alpha is multiplied
+         * with the src alpha, but not with the RGB components unless
+         * src premultiply, premultcolor or src blend DSBF_SRCALPHA is set.
+         * Unfortunately the hardware always multiplies RGB by the global alpha
+         * register.
+         */
+        if(!(state->blittingflags & (DSBLIT_SRC_PREMULTIPLY | DSBLIT_SRC_PREMULTCOLOR)) && (state->src_blend != DSBF_SRCALPHA))
+          goto exit;
+
+
+        if((state->blittingflags & DSBLIT_SRC_PREMULTCOLOR) && !canUseHWInputMatrix)
+        {
+          /*
+           * We can't do more than one multiply of alpha with color except on
+           * BDisp based parts when the source is RGB or expanded Clut data. In
+           * that case we can use the input matrix to do the premultcolor.
+           */
+          if((state->blittingflags & DSBLIT_SRC_PREMULTIPLY) || (state->src_blend == DSBF_SRCALPHA))
+            goto exit;
+        }
+
+      }
+      else if((state->blittingflags & DSBLIT_SRC_PREMULTCOLOR) && !canUseHWInputMatrix)
+      {
+        /*
+         * Premultcolor without coloralpha needs the BDisp input matrix
+         */
+        goto exit;
+      }
+
+
+      /*
+       * We can do blend from alpha channel on all surface formats as on formats
+       * without alpha the hardware fills in "full" alpha for us. However we
+       * can only do source premultiplication if the src func != DSBF_SRCALPHA
+       */
+      if((state->blittingflags & DSBLIT_SRC_PREMULTIPLY) && (state->src_blend == DSBF_SRCALPHA))
+          goto exit;
+
+      /*
+       * We can do src func = DSBF_SRCALPHA as long as there is no incompatible
+       * pre-multiply (src alpha or color alpha, which has already been tested
+       * for) and the destination does not have an alpha channel.
+       *
+       * This is becuase the hardware cannot calculate the correct alpha for
+       * the destination but can calculate the correct RGB values. This is
+       * supported to accelerate the blit-blend performance test in df_dok
+       * for the standard 16bit destination.
+       */
+      if(dstHasAlpha && (state->src_blend == DSBF_SRCALPHA))
+          goto exit;
+
+    }
+    else if(state->blittingflags & DSBLIT_BLEND_COLORALPHA)
+    {
+      /*
+       * color alpha on its own (i.e. no DSBLIT_BLEND_ALPHACHANNEL). Supported
+       * blend modes + flags:
+       *
+       * (1) src func = 0, dst func = 0 (clear)
+       * (2) src func = 0, dst func = 1 (nop)
+       * (3) src func = 1, dst func = 0 (copy), any dest surface, premultiply and/or premultcolor on
+       * (4) src func = 1, dst func = 1-alpha, any dest surface, premultiply and/or premultcolor on
+       * (5) src func = src alpha, dst func = 1-src alpha, no premultiply, non alpha dest surface
+       *
+       * The source must be an RGB surface with no existing alpha channel in
+       * the last three cases. Note that this doesn't include DSPF_RGB32 as the
+       * hardware will insist on using the top unused 8 bits as an alpha channel.
+       * We have no way of forcing the alpha channel to be fully opqaue.
+       *
+       * The reason for this is that COLORALPHA on its own replaces the src alpha
+       * channel with the alpha value from the colour register. Unfortunately the
+       * hardware cannot do this, it always multiplies the source alpha with
+       * its global alpha register. So we can only accelerate this when the
+       * source alpha is always 1.0f, i.e. surface formats that do not contain
+       * an alpha channel, or for those obscure blend modes where the src is
+       * discarded.
+       *
+       */
+      if(!supportedBlend)
+        goto exit;
+
+      if(state->blittingflags & DSBLIT_XOR)
+        goto exit;
+
+      if(state->src_blend == DSBF_ONE)
+      {
+        if(srcHasAlpha || !(state->blittingflags & (DSBLIT_SRC_PREMULTIPLY | DSBLIT_SRC_PREMULTCOLOR)))
+          goto exit;
+
+      }
+      else if(state->src_blend == DSBF_SRCALPHA && state->dst_blend == DSBF_INVSRCALPHA)
+      {
+        if(srcHasAlpha || dstHasAlpha || (state->blittingflags & DSBLIT_SRC_PREMULTIPLY))
+          goto exit;
+      }
+
+      if((state->blittingflags & DSBLIT_SRC_PREMULTCOLOR) && !canUseHWInputMatrix)
+      {
+        /*
+         * We can't do more than one multiply of alpha with color except on
+         * BDisp based parts when the source is RGB or expanded Clut data. In
+         * that case we can use the input matrix to do the premultcolor.
+         */
+        if((state->blittingflags & DSBLIT_SRC_PREMULTIPLY) || (state->src_blend != DSBF_SRCALPHA))
+          goto exit;
+      }
+
+    }
+    else
+    {
+      /*
+       * We can only format convert DSBF_RGB32 to other formats that do not
+       * have an alpha channel. We allow this to accelerate the df_dok
+       * performance test blit-convert. But these limitations make this
+       * surface format pretty useless.
+       */
+      if(state->source->format == DSPF_RGB32)
+      {
+        if(dstHasAlpha || (state->blittingflags & DSBLIT_SRC_PREMULTIPLY))
+          goto exit;
+      }
+
+      /*
+       * We cannot XOR and premultiply by src alpha at the same time
+       */
+      if((state->blittingflags & (DSBLIT_XOR|DSBLIT_SRC_PREMULTIPLY)) == (DSBLIT_XOR|DSBLIT_SRC_PREMULTIPLY))
+        goto exit;
+
+      /*
+       * In this case we need the input matrix on the BDisp to do premultcolor.
+       */
+      if((state->blittingflags & DSBLIT_SRC_PREMULTCOLOR) && !canUseHWInputMatrix)
+      {
+        goto exit;
+      }
+    }
+
+    state->accel |= STGFX_VALID_BLITTINGFUNCTIONS;
+  }
+
+exit:
+/*  printf("check state - state->accel = 0x%x\n",state->accel);*/
+  return;
+}
+
+typedef struct  _PIX_FMT_TBL {
+    unsigned long  stgBlitFmt;
+    char          *string;
+    bool           supportedAsSrc;
+    bool           supportedAsDst;
+}PIX_FMT_TBL;
+
+
+static const PIX_FMT_TBL format_tbl_bdisp[DFB_NUM_PIXELFORMATS] = {
+    /*
+     * Note: we specify that LUT formats have an alpha channel, because as a source
+     * it does once the colour lookup has taken place; hence any blending
+     * restrictions will apply.
+     *
+     * Note2: CLUT2 is not supported as a target type on BDISP at the moment.
+     */
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB1555)] = { SURF_ARGB1555,  "SURF_ARGB1555 16bpp alp",        true,  true },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB16)]    = { SURF_RGB565,    "SURF_RGB565 16bpp",              true,  true },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB24)]    = { SURF_RGB888,    "SURF_RGB888 24 bpp - packed",    true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB32)]    = { SURF_ARGB8888,  "SURF_ARGB8888 32 bpp - no alpha",true,  false },
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB)]     = { SURF_ARGB8888,  "SURF_ARGB8888 32bpp alp",        true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_A8)]       = { SURF_A8,        "SURF_A8",                        true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_YUY2)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB332)]   = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_UYVY)]     = { SURF_YCBCR422R, "SURF_YCBCR422R",                 true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_I420)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_YV12)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_LUT8)]     = { SURF_CLUT8,     "SURF_CLUT8",                     true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_ALUT44)]   = { SURF_ACLUT44,   "SURF_ACLUT44",                   true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_AiRGB)]    = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_A1)]       = { SURF_A1,        "SURF_A1",                        true,  false },
+    [DFB_PIXELFORMAT_INDEX (DSPF_NV12)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_NV16)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB2554)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB4444)] = { SURF_ARGB4444,  "SURF_ARGB4444 16bpp",            true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_NV21)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_AYUV)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_A4)]       = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB1666)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB6666)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB18)]    = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_LUT2)]     = { SURF_CLUT2,     "SURF_CLUT2",                     true,  false },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB444)]   = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB555)]   = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB8565)] = { SURF_ARGB8565,  "SURF_ARGB8565 24bpp alp",        true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_AVYU)]     = { SURF_ACRYCB8888,"SURF_ACRYCB8888 32bpp YUV alp",  true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_VYU)]      = { SURF_CRYCB888,  "SURF_CRYCB888 24bpp YUV",        true,  true  }
+};
+
+
+static const PIX_FMT_TBL format_tbl_gamma[DFB_NUM_PIXELFORMATS] = {
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB1555)] = { SURF_ARGB1555,  "SURF_ARGB1555 16bpp alp",        true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB16)]    = { SURF_RGB565,    "SURF_RGB565 16bpp",              true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB24)]    = { SURF_RGB888,    "SURF_RGB888 24 bpp - packed",    true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB32)]    = { SURF_ARGB8888,  "SURF_ARGB8888 32 bpp - no alpha",true,  false },
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB)]     = { SURF_ARGB8888,  "SURF_ARGB8888 32bpp alp",        true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_A8)]       = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_YUY2)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB332)]   = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_UYVY)]     = { SURF_YCBCR422R, "SURF_YCBCR422R",                 true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_I420)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_YV12)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_LUT8)]     = { SURF_CLUT8,     "SURF_CLUT8",                     true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_ALUT44)]   = { SURF_ACLUT44,   "SURF_ACLUT44",                   true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_AiRGB)]    = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_A1)]       = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_NV12)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_NV16)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB2554)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB4444)] = { SURF_ARGB4444,  "SURF_ARGB4444 16bpp",            true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_NV21)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_AYUV)]     = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_A4)]       = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB1666)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB6666)] = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB18)]    = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_LUT2)]     = { SURF_CLUT2,     "SURF_CLUT2",                     true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB444)]   = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_RGB555)]   = {},
+    [DFB_PIXELFORMAT_INDEX (DSPF_ARGB8565)] = { SURF_ARGB8565,  "SURF_ARGB8565 24bpp alp",        true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_AVYU)]     = { SURF_ACRYCB8888,"SURF_ACRYCB8888 32bpp YUV alp",  true,  true  },
+    [DFB_PIXELFORMAT_INDEX (DSPF_VYU)]      = { SURF_CRYCB888,  "SURF_CRYCB888 24bpp YUV",        true,  true  }
+};
+
+
+static const PIX_FMT_TBL *format_tbl;
+
+
+static bool stgfxCheckPixelFormat(DFBSurfacePixelFormat dfbFmt,
+                                  bool bSrc, bool *hasAlpha, bool *isClut)
+{
+  D_ASSERT (dfbFmt != DSPF_UNKNOWN);
+  if (!dfbFmt)
+    return false;
+
+  const PIX_FMT_TBL * const format = &format_tbl[DFB_PIXELFORMAT_INDEX (dfbFmt)];
+
+  *hasAlpha = DFB_PIXELFORMAT_HAS_ALPHA (dfbFmt);
+  *isClut   = DFB_PIXELFORMAT_IS_INDEXED (dfbFmt);
+
+  return bSrc ? format->supportedAsSrc : format->supportedAsDst;
+}
+
+
+static unsigned long stgfxSetPixelFormat(DFBSurfacePixelFormat dfbFmt)
+{
+  D_ASSERT (dfbFmt != DSPF_UNKNOWN);
+  if (!dfbFmt)
+    return 0;
+
+  return format_tbl[DFB_PIXELFORMAT_INDEX (dfbFmt)].stgBlitFmt;
+}
+
+
+/**********************************************************************/
+/* DirectFB has requested a modified state.                           */
+/* Check which fields have been modified and then update the fields   */
+/* that are necessary for the operation indicated by accel            */
+/**********************************************************************/
+static void stgfxSetState
+(
+  void*                 drv,
+  void*                 dev,
+  GraphicsDeviceFuncs*  funcs,
+  CardState*            state,
+  DFBAccelerationMask   accel
+)
+{
+  STGFXDriverData *pDrv = (STGFXDriverData*) drv;
+  STGFXDeviceData *pDev = (STGFXDeviceData*) dev;
+
+  /*
+   * First update the flags, as the rest depends on these being
+   * correct.
+   */
+  if (state->modified & SMF_DRAWING_FLAGS)
+    pDev->drawingFlags = state->drawingflags;
+
+  if (state->modified & SMF_BLITTING_FLAGS)
+  {
+    pDev->blittingFlags        =  state->blittingflags;
+    pDev->bBlendFromColorAlpha = (state->blittingflags & DSBLIT_BLEND_COLORALPHA)   ? true : false;
+    pDev->bBlendFromSrcAlpha   = (state->blittingflags & DSBLIT_BLEND_ALPHACHANNEL) ? true : false;
+    pDev->bSrcPremultiply      = (state->blittingflags & DSBLIT_SRC_PREMULTIPLY)    ? true : false;
+    pDev->bPremultColor        = (state->blittingflags & DSBLIT_SRC_PREMULTCOLOR)   ? true : false;
+  }
+
+  if (state->modified & SMF_DESTINATION)
+    stgfxSetDestination(pDev, state);
+
+  if (state->modified & SMF_SOURCE)
+    stgfxSetSource(pDrv, pDev, state);
+
+  /*
+   * Make sure that the colour gets updated when the drawing or blitting flags
+   * or the destination surface format change, as we have to modify the colour
+   * for fills.
+   */
+  if (state->modified & (SMF_COLOR | SMF_DRAWING_FLAGS | SMF_DESTINATION))
+    stgfxSetColour(pDev, state);
+
+  if (state->modified & SMF_SRC_BLEND)
+    pDev->srcBlendFunc = state->src_blend;
+
+  if (state->modified & SMF_DST_BLEND)
+    pDev->dstBlendFunc = state->dst_blend;
+
+  if (state->modified & SMF_SRC_COLORKEY)
+    pDev->srcColourKey = state->src_colorkey;
+
+  if (state->modified & SMF_DST_COLORKEY)
+    pDev->dstColourKey = state->dst_colorkey;
+
+  switch (accel)
+  {
+    case DFXL_FILLRECTANGLE:
+    case DFXL_DRAWRECTANGLE:
+      state->set |= (DFXL_FILLRECTANGLE | DFXL_DRAWRECTANGLE);
+      break;
+
+    case DFXL_BLIT:
+    case DFXL_STRETCHBLIT:
+      state->set |= (DFXL_BLIT | DFXL_STRETCHBLIT);
+      break;
+
+    default:
+      /* Should never happen as we have told DirectFB which functions we can support*/
+      D_ERROR( "DirectFB/gfxdrivers/stgfx: unexpected drawing/blitting function" );
+      break;
+  }
+
+  state->modified = (StateModificationFlags)0;
+}
+
+/********************************************************************************************/
+/* Fill the rectangle 'rect' with the colour that has been previously specified in setstate */
+/********************************************************************************************/
+static bool stgfxFillRectangle
+(
+  void* drv,
+  void* dev,
+  DFBRectangle* rect
+)
+{
+  STGFXDriverData*  pDrv = (STGFXDriverData*) drv;
+  STGFXDeviceData*  pDev = (STGFXDeviceData*) dev;
+  STMFBIO_BLT_DATA  bltData;
+
+  bzero(&bltData, sizeof(STMFBIO_BLT_DATA));
+
+  bltData.operation = BLT_OP_FILL;
+  return stgfxDraw(pDrv, pDev, rect, &bltData);
+}
+
+/********************************************************************************************/
+/* Draw the rectangle 'rect' with the colour that has been previously specified in setstate */
+/********************************************************************************************/
+static bool stgfxDrawRectangle
+(
+  void* drv,
+  void* dev,
+  DFBRectangle* rect
+)
+{
+  STGFXDriverData*  pDrv = (STGFXDriverData*) drv;
+  STGFXDeviceData*  pDev = (STGFXDeviceData*) dev;
+  STMFBIO_BLT_DATA  bltData;
+
+  bzero(&bltData, sizeof(STMFBIO_BLT_DATA));
+
+  bltData.operation = BLT_OP_DRAW_RECTANGLE;
+  return stgfxDraw(pDrv, pDev, rect, &bltData);
+}
+
+
+/******************************/
+/* Blit from 'rect' to dx, dy */
+/******************************/
+static bool stgfxBlit
+(
+  void*         drv,
+  void*         dev,
+  DFBRectangle* rect,
+  int           dx,
+  int           dy
+)
+{
+  STGFXDriverData*  pDrv = (STGFXDriverData*) drv;
+  STGFXDeviceData*  pDev = (STGFXDeviceData*) dev;
+  STMFBIO_BLT_DATA  bltData;
+
+  bzero(&bltData, sizeof(STMFBIO_BLT_DATA));
+
+  if(!stgfxCommonBlitData(pDrv, pDev, &bltData))
+  {
+    /* We don't need to do the operation as it would be a nop */
+    return true;
+  }
+
+  if(!stgfxUpdatePalette(pDrv, pDev, &bltData))
+    return false;
+
+  bltData.src_left   = (unsigned short)rect->x;
+  bltData.src_top    = (unsigned short)rect->y;
+  bltData.src_right  = (unsigned short)(rect->x + rect->w);
+  bltData.src_bottom = (unsigned short)(rect->y + rect->h);
+
+  bltData.dst_left   = (unsigned short)dx;
+  bltData.dst_top    = (unsigned short)dy;
+  bltData.dst_right  = (unsigned short)(dx + rect->w);
+  bltData.dst_bottom = (unsigned short)(dy + rect->h);
+
+  if (ioctl(pDrv->fd, STMFBIO_BLT, &bltData ) < 0)
+  {
+    return false;
+  }
+
+  return true;
+}
+
+/**************************/
+/* Blit from 'sr' to 'dr' */
+/**************************/
+
+static bool stgfxStretchBlit
+(
+  void*         drv,
+  void*         dev,
+  DFBRectangle* sr,
+  DFBRectangle* dr
+)
+{
+  STGFXDriverData*  pDrv = (STGFXDriverData*) drv;
+  STGFXDeviceData*  pDev = (STGFXDeviceData*) dev;
+  STMFBIO_BLT_DATA  bltData;
+
+  bzero(&bltData, sizeof(STMFBIO_BLT_DATA));
+
+  if(!stgfxCommonBlitData(pDrv, pDev, &bltData))
+  {
+    /* We don't need to do the operation as it would be a nop */
+    return true;
+  }
+
+  if(!stgfxUpdatePalette(pDrv, pDev, &bltData))
+    return false;
+
+  bltData.src_left   = (unsigned short)sr->x;
+  bltData.src_top    = (unsigned short)sr->y;
+  bltData.src_right  = (unsigned short)(sr->x + sr->w);
+  bltData.src_bottom = (unsigned short)(sr->y + sr->h);
+
+  bltData.dst_left   = (unsigned short)dr->x;
+  bltData.dst_top    = (unsigned short)dr->y;
+  bltData.dst_right  = (unsigned short)(dr->x + dr->w);
+  bltData.dst_bottom = (unsigned short)(dr->y + dr->h);
+
+  if (ioctl(pDrv->fd, STMFBIO_BLT, &bltData ) < 0)
+  {
+    return false;
+  }
+
+  return true;
+}
+
+/* exported symbols - These functions must be present*/
+
+/************************************************************/
+/* Check if the hardware is ours by looking at the value    */
+/* returned in the accel field of the framebuffer fixed info*/
+/************************************************************/
+static int driver_probe(GraphicsDevice* device)
+{
+  int result = 0;
+  int accel = dfb_gfxcard_get_accelerator( device );
+
+  switch (accel)
+  {
+  case FB_ACCEL_ST_GAMMA:
+    D_DEBUG( "DirectFB/STGFX: Found FB_ACCEL_ST_GAMMA\n" );
+    result = 1;
+    break;
+  case FB_ACCEL_ST_BDISP:
+    D_DEBUG( "DirectFB/STGFX: Found FB_ACCEL_ST_BDISP\n" );
+    result = 1;
+    break;
+  default:
+    D_DEBUG( "DirectFB/STGFX: unrecognised accelerator %d\n",accel );
+    break;
+  }
+
+  return result;
+}
+
+/***************************************************/
+/* Return some human readable info about our driver*/
+/***************************************************/
+static void driver_get_info(GraphicsDevice *device, GraphicsDriverInfo *info)
+{
+  /* fill driver info structure */
+  int accel = dfb_gfxcard_get_accelerator( device );
+
+  switch (accel)
+  {
+    case FB_ACCEL_ST_GAMMA:
+      snprintf( info->name, DFB_GRAPHICS_DRIVER_INFO_NAME_LENGTH, "ST Microelectronics Gamma" );
+      break;
+    case FB_ACCEL_ST_BDISP:
+      snprintf( info->name, DFB_GRAPHICS_DRIVER_INFO_NAME_LENGTH, "ST Microelectronics BDisp" );
+      break;
+    default:
+      break;
+  }
+
+  snprintf( info->vendor, DFB_GRAPHICS_DRIVER_INFO_VENDOR_LENGTH, "ST Microelectronics" );
+
+  info->version.major = 0;
+  info->version.minor = 99;
+
+  /* Tell directFB how big our device and driver structures are*/
+  info->driver_data_size = sizeof (STGFXDriverData);
+  info->device_data_size = sizeof (STGFXDeviceData);
+}
+
+/****************************************************************/
+/* Set the function pointers for the acceleration functions.    */
+/* This does not tell DirectFB what we support, this is done in */
+/* driver_init_device.                                          */
+/****************************************************************/
+static DFBResult driver_init_driver
+(
+  GraphicsDevice*       device,
+  GraphicsDeviceFuncs*  funcs,
+  void*                 driver_data,
+  void*                 device_data,
+  CoreDFB*              core
+)
+{
+  STGFXDriverData*  pDrv = (STGFXDriverData*) driver_data;
+
+  /* Zero'd function pointers for function we do not support*/
+  /* just to be tidy, this isn't required by DirectFB*/
+
+  funcs->AfterSetVar        = 0;
+  funcs->EngineSync         = stgfxEngineSync;
+  funcs->FlushTextureCache  = 0;
+  funcs->CheckState         = stgfxCheckState;
+  funcs->SetState           = stgfxSetState;
+  funcs->FillRectangle      = stgfxFillRectangle;
+  funcs->DrawRectangle      = stgfxDrawRectangle;
+  funcs->DrawLine           = 0;
+  funcs->FillTriangle       = 0;
+  funcs->Blit               = stgfxBlit;
+  funcs->StretchBlit        = stgfxStretchBlit;
+
+  /*
+   * Get the framebuffer file descriptor. Because we successfully
+   * probed ourselves the system _must_ be a framebuffer device
+   */
+  pDrv->fd = -1;
+
+  FBDev *dfb_fbdev = (FBDev *)dfb_system_data();
+
+  if(dfb_fbdev == NULL)
+  {
+    D_ERROR("DirectFB/gfxdrivers/stgfx: No System data\n");
+    return DFB_IO;
+  }
+
+  pDrv->fd = dfb_fbdev->fd;
+
+  if (pDrv->fd < 0)
+  {
+    D_ERROR("DirectFB/gfxdrivers/stgfx: Bad FB File Descriptor\n");
+    return DFB_IO;
+  }
+
+  D_ERROR("DirectFB/gfxdrivers/stgfx: FB file descriptor = %d\n",pDrv->fd);
+
+  /*
+   * Setup the driver state here. This cannot be done in probe as we need to
+   * do it for slaves in multiapp mode and probe is only called by the master
+   * application.
+   */
+  stgfx_accel_type = dfb_gfxcard_get_accelerator( device );
+
+  switch (stgfx_accel_type)
+  {
+  case FB_ACCEL_ST_GAMMA:
+    format_tbl = format_tbl_gamma;
+    STGFX_VALID_DRAWINGFLAGS  = STGFX_VALID_DRAWINGFLAGS_GAMMA;
+    STGFX_VALID_BLITTINGFLAGS = STGFX_VALID_BLITTINGFLAGS_GAMMA;
+    break;
+  case FB_ACCEL_ST_BDISP:
+    format_tbl = format_tbl_bdisp;
+    STGFX_VALID_DRAWINGFLAGS  = STGFX_VALID_DRAWINGFLAGS_BDISP;
+    STGFX_VALID_BLITTINGFLAGS = STGFX_VALID_BLITTINGFLAGS_BDISP;
+    break;
+  default:
+    return DFB_IO;
+  }
+
+  dfb_layers_hook_primary( device, driver_data,
+                                  &stgfxPrimaryLayerFuncs,
+                                  &pDrv->primaryLayerFuncs,
+                                  &pDrv->primaryDriverData );
+
+
+  return DFB_OK;
+}
+
+/***************************/
+/* Initialise the hardware */
+/***************************/
+static DFBResult driver_init_device
+(
+  GraphicsDevice*     device,
+  GraphicsDeviceInfo* device_info,
+  void*               driver_data,
+  void*               device_data
+)
+{
+  DFBResult result  = DFB_OK;
+  int accel = dfb_gfxcard_get_accelerator( device );
+
+  switch (accel)
+  {
+    case FB_ACCEL_ST_GAMMA:
+      snprintf( device_info->name, DFB_GRAPHICS_DEVICE_INFO_NAME_LENGTH, "Gamma" );
+      break;
+    case FB_ACCEL_ST_BDISP:
+      snprintf( device_info->name, DFB_GRAPHICS_DEVICE_INFO_NAME_LENGTH, "BDisp" );
+      break;
+    default:
+      break;
+  }
+
+  snprintf( device_info->vendor,
+    DFB_GRAPHICS_DEVICE_INFO_VENDOR_LENGTH,
+    "ST Microelectronics" );
+
+
+  /* Tell directFB about what operations we may be able to do   */
+  device_info->caps.flags    = CCF_NOTRIEMU;
+  device_info->caps.accel    = STGFX_VALID_DRAWINGFUNCTIONS | STGFX_VALID_BLITTINGFUNCTIONS;
+  device_info->caps.drawing  = STGFX_VALID_DRAWINGFLAGS;
+  device_info->caps.blitting = STGFX_VALID_BLITTINGFLAGS;
+
+  /* Give directFB info about our surface limitations*/
+  device_info->limits.surface_byteoffset_alignment = 4;
+  device_info->limits.surface_bytepitch_alignment  = 2;
+  device_info->limits.surface_pixelpitch_alignment = 1;
+
+  return result;
+}
+
+
+/*************************************************/
+/* Do any hardware shutdown that may be required */
+/*************************************************/
+static void driver_close_device
+(
+  GraphicsDevice* device,
+  void*           driver_data,
+  void*           device_data
+)
+{
+  STGFXDeviceData* pDev = (STGFXDeviceData*) device_data;
+  (void)pDev;
+}
+
+/*****************/
+/* Driver de-init*/
+/*****************/
+static void driver_close_driver
+(
+  GraphicsDevice* device,
+  void*           driver_data
+)
+{
+  STGFXDriverData*  pDrv = (STGFXDriverData*) driver_data;
+
+  if (pDrv->fd >= 0)
+  {
+    /*
+     * Try and restore the framebuffer's extended state.
+     */
+    pDrv->originalVar.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+    ioctl(pDrv->fd, STMFBIO_SET_VAR_SCREENINFO_EX, &pDrv->originalVar);
+    pDrv->fd = -1;
+  }
+
+}
Index: DirectFB-1.0.1/gfxdrivers/stgfx/Makefile.am
===================================================================
--- DirectFB-1.0.1.orig/gfxdrivers/stgfx/Makefile.am	2007-09-24 14:46:01.129285527 +0100
+++ DirectFB-1.0.1/gfxdrivers/stgfx/Makefile.am	2007-09-24 14:46:01.689327771 +0100
@@ -16,7 +16,8 @@ endif
 stgfxdir = $(MODULEDIR)/gfxdrivers
 
 libdirectfb_stgfx_la_SOURCES =	\
-	stgfx.c
+	stgfx.c			\
+	stgfx_primary.c
 
 libdirectfb_stgfx_la_LDFLAGS = \
         -export-dynamic		\
Index: DirectFB-1.0.1/gfxdrivers/stgfx/stgfx.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ DirectFB-1.0.1/gfxdrivers/stgfx/stgfx.h	2007-09-24 14:52:44.931570794 +0100
@@ -0,0 +1,35 @@
+/*
+   (c) Copyright 2007       STMicroelectronics.
+
+   All rights reserved.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+typedef struct {
+  int                              fd;
+  void                            *primaryDriverData;
+  DisplayLayerFuncs                primaryLayerFuncs;
+  struct stmfbio_var_screeninfo_ex originalVar;
+} STGFXDriverData;
+
+typedef struct {
+  u32                              originalVarCaps;
+  DFBDisplayLayerOptions           primaryLayerOptions;
+  DFBColorAdjustmentFlags          primaryLayerAdjustments;
+} STGFXDriverSharedData;
+
+DisplayLayerFuncs stgfxPrimaryLayerFuncs;
Index: DirectFB-1.0.1/gfxdrivers/stgfx/stgfx_primary.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ DirectFB-1.0.1/gfxdrivers/stgfx/stgfx_primary.c	2007-09-24 14:56:17.639489607 +0100
@@ -0,0 +1,450 @@
+/*
+   (c) Copyright 2007       STMicroelectronics.
+   (c) Copyright 2000-2002  convergence integrated media GmbH.
+   (c) Copyright 2002       convergence GmbH.
+
+   All rights reserved.
+
+   Based on the cle266 driver implementation:
+
+   Written by Denis Oliver Kropp <dok@directfb.org>,
+              Andreas Hundt <andi@fischlustig.de> and
+              Sven Neumann <sven@convergence.de>.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+
+#include <linux/fb.h>
+#include <linux/stmfb.h>
+
+#include <directfb.h>
+
+#include <core/layers.h>
+#include <direct/debug.h>
+#include <misc/conf.h>
+#include <gfx/convert.h>
+
+#include "stgfx.h"
+
+static DFBResult stgfxPrimaryInitLayer( CoreLayer                  *layer,
+                                        void                       *driver_data,
+                                        void                       *layer_data,
+                                        DFBDisplayLayerDescription *description,
+                                        DFBDisplayLayerConfig      *config,
+                                        DFBColorAdjustment         *adjustment )
+{
+  DFBResult              ret;
+  STGFXDriverData       *drv = (STGFXDriverData*) driver_data;
+  STGFXDriverSharedData *shd = (STGFXDriverSharedData*) layer_data;
+
+  D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: init layer\n");
+
+  /* call the original initialization function first */
+  ret = drv->primaryLayerFuncs.InitLayer( layer,
+                                          drv->primaryDriverData,
+                                          layer_data, description,
+                                          config, adjustment );
+  if (ret)
+    return ret;
+
+  memset(&drv->originalVar, 0, sizeof(struct stmfbio_var_screeninfo_ex));
+
+  /*
+   * Note we cannot use dfb_layer_id_translated because it requires state that
+   * will not be setup until this hook has completed.
+   */
+  drv->originalVar.layerid = dfb_config->primary_layer;
+
+  if(ioctl(drv->fd,STMFBIO_GET_VAR_SCREENINFO_EX, &drv->originalVar) < 0)
+  {
+    /*
+     * We have a framebuffer driver that doesn't support the extended var
+     * stuff, so ignore it, it will be as if we are a dumb framebuffer.
+     */
+    drv->originalVar.caps = STMFBIO_VAR_CAPS_NONE;
+    shd->originalVarCaps  = STMFBIO_VAR_CAPS_NONE;
+    return DFB_OK;
+  }
+
+  /* Duplicate originalVar.caps into Shared Memory for Fusion Slaves. */
+  shd->originalVarCaps = drv->originalVar.caps;
+
+  D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: got extended var\n");
+
+  /* set name */
+  snprintf(description->name,
+           DFB_DISPLAY_LAYER_DESC_NAME_LENGTH, "STM Graphics Plane");
+
+  shd->primaryLayerOptions     = DLOP_NONE;
+  shd->primaryLayerAdjustments = DCAF_NONE;
+
+  /* add support alphachannel, we always do this */
+  config->flags           |= DLCONF_OPTIONS;
+  config->options          = DLOP_ALPHACHANNEL;
+  shd->primaryLayerOptions = DLOP_ALPHACHANNEL;
+  description->caps       |= DLCAPS_ALPHACHANNEL;
+
+  if(drv->originalVar.caps & STMFBIO_VAR_CAPS_COLOURKEY)
+  {
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: supports src colourkey\n");
+    shd->primaryLayerOptions |= DLOP_SRC_COLORKEY;
+    description->caps        |= DLCAPS_SRC_COLORKEY;
+  }
+
+  if(drv->originalVar.caps & STMFBIO_VAR_CAPS_FLICKER_FILTER)
+  {
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: supports flicker filtering\n");
+    shd->primaryLayerOptions |= DLOP_FLICKER_FILTERING;
+    description->caps        |= DLCAPS_FLICKER_FILTERING;
+  }
+
+  if(drv->originalVar.caps & STMFBIO_VAR_CAPS_PREMULTIPLIED)
+  {
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: supports pre-multiplied alpha\n");
+    config->flags        |= DLCONF_SURFACE_CAPS;
+    config->surface_caps  = DSCAPS_PREMULTIPLIED;
+    description->caps    |= DLCAPS_PREMULTIPLIED;
+  }
+
+  if(drv->originalVar.caps & STMFBIO_VAR_CAPS_OPACITY)
+  {
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: supports opacity\n");
+    config->options          |= DLOP_OPACITY;
+    /*
+     * Strangely we cannot specify the default layer opacity, lets hope its
+     * fully opaque!
+     */
+    shd->primaryLayerOptions |= DLOP_OPACITY;
+    description->caps        |= DLCAPS_OPACITY;
+  }
+
+  adjustment->flags = 0;
+
+  if(drv->originalVar.caps & (STMFBIO_VAR_CAPS_GAIN | STMFBIO_VAR_CAPS_BRIGHTNESS))
+  {
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: supports gain/brightness adjustment\n");
+    shd->primaryLayerAdjustments |= DCAF_BRIGHTNESS;
+    adjustment->flags            |= DCAF_BRIGHTNESS;
+    adjustment->brightness        = 0x8000;
+    description->caps            |= DLCAPS_BRIGHTNESS;
+  }
+
+  if(drv->originalVar.caps & STMFBIO_VAR_CAPS_CONTRAST)
+  {
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: supports contrast adjustment\n");
+    shd->primaryLayerAdjustments |= DCAF_CONTRAST;
+    adjustment->flags            |= DCAF_CONTRAST;
+    adjustment->contrast          = 0x8000;
+    description->caps            |= DLCAPS_CONTRAST;
+  }
+
+  if(drv->originalVar.caps & STMFBIO_VAR_CAPS_TINT)
+  {
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: supports tint adjustment\n");
+    shd->primaryLayerAdjustments |= DCAF_HUE;
+    adjustment->flags            |= DCAF_HUE;
+    adjustment->hue               = 0x8000;
+    description->caps            |= DLCAPS_HUE;
+  }
+
+  if(drv->originalVar.caps & STMFBIO_VAR_CAPS_SATURATION)
+  {
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: supports saturation adjustment\n");
+    shd->primaryLayerAdjustments |= DCAF_SATURATION;
+    adjustment->flags            |= DCAF_SATURATION;
+    adjustment->saturation        = 0x8000;
+    description->caps            |= DLCAPS_SATURATION;
+  }
+
+  if(drv->originalVar.caps & STMFBIO_VAR_CAPS_ALPHA_RAMP)
+  {
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: supports RGB1555 alpha ramp\n");
+    description->caps |= DLCAPS_ALPHA_RAMP;
+  }
+
+  if(drv->originalVar.caps & STMFBIO_VAR_CAPS_ZPOSITION)
+  {
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: supports plane re-ordering\n");
+    description->caps |= DLCAPS_LEVELS;
+    description->level = drv->originalVar.z_position;
+  }
+
+  return DFB_OK;
+}
+
+
+static DFBResult stgfxPrimaryTestRegion( CoreLayer                  *layer,
+                                         void                       *driver_data,
+                                         void                       *layer_data,
+                                         CoreLayerRegionConfig      *config,
+                                         CoreLayerRegionConfigFlags *failed )
+{
+   DFBResult                  ret;
+   CoreLayerRegionConfigFlags fail = 0;
+   DFBDisplayLayerOptions     options = config->options;
+   STGFXDriverData           *drv = (STGFXDriverData*) driver_data;
+   STGFXDriverSharedData     *shd = (STGFXDriverSharedData*) layer_data;
+
+   /* remove options before calling the original function */
+   config->options = DLOP_NONE;
+
+   ret = drv->primaryLayerFuncs.TestRegion( layer, drv->primaryDriverData,
+                                            layer_data, config, &fail );
+
+   /* restore options */
+   config->options = options;
+
+   /* check options if specified */
+   if (options && ((options & ~shd->primaryLayerOptions) != 0))
+     fail |= CLRCF_OPTIONS;
+
+   if ( (config->surface_caps & DSCAPS_PREMULTIPLIED) &&
+       !(shd->originalVarCaps & STMFBIO_VAR_CAPS_PREMULTIPLIED))
+   {
+     fail |= CLRCF_SURFACE_CAPS;
+   }
+
+   if (failed)
+     *failed = fail;
+
+   if (fail)
+     return DFB_UNSUPPORTED;
+
+   return ret;
+}
+
+
+static DFBResult stgfxPrimarySetRegion( CoreLayer                  *layer,
+                                        void                       *driver_data,
+                                        void                       *layer_data,
+                                        void                       *region_data,
+                                        CoreLayerRegionConfig      *config,
+                                        CoreLayerRegionConfigFlags  updated,
+                                        CoreSurface                *surface,
+                                        CorePalette                *palette )
+{
+  DFBResult                         ret;
+  STGFXDriverData                  *drv = (STGFXDriverData*) driver_data;
+  STGFXDriverSharedData            *shd = (STGFXDriverSharedData*) layer_data;
+  struct stmfbio_var_screeninfo_ex  tmp = {0};
+
+  D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: set region layer = %p config = %p surface = %p\n",layer,config,surface);
+
+  /* call the original function */
+  ret = drv->primaryLayerFuncs.SetRegion( layer, drv->primaryDriverData,
+                                          layer_data, region_data,
+                                          config, updated, surface,
+                                          palette );
+  if (ret)
+    return ret;
+
+  if(shd->originalVarCaps == STMFBIO_VAR_CAPS_NONE)
+    return DFB_OK;
+
+  D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: set extended layer options\n");
+
+  tmp.layerid  = dfb_layer_id_translated(layer);
+  tmp.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+
+  if((updated & (CLRCF_OPTIONS | CLRCF_SRCKEY)) &&
+     (shd->originalVarCaps & STMFBIO_VAR_CAPS_COLOURKEY))
+  {
+    tmp.caps          |= STMFBIO_VAR_CAPS_COLOURKEY;
+    tmp.colourKeyFlags = (config->options & DLOP_SRC_COLORKEY)?STMFBIO_COLOURKEY_FLAGS_ENABLE:0;
+    tmp.min_colour_key = PIXEL_ARGB(0, config->src_key.r, config->src_key.g, config->src_key.b);
+    tmp.max_colour_key = tmp.min_colour_key;
+  }
+
+  if((updated & CLRCF_OPTIONS) &&
+     (shd->originalVarCaps & STMFBIO_VAR_CAPS_FLICKER_FILTER))
+  {
+    tmp.caps    |= STMFBIO_VAR_CAPS_FLICKER_FILTER;
+    tmp.ff_state = (config->options & DLOP_FLICKER_FILTERING)?STMFBIO_FF_ADAPTIVE:STMFBIO_FF_OFF;
+  }
+
+  if((updated & CLRCF_SURFACE_CAPS) &&
+     (shd->originalVarCaps & STMFBIO_VAR_CAPS_PREMULTIPLIED))
+  {
+    tmp.caps |= STMFBIO_VAR_CAPS_PREMULTIPLIED;
+    tmp.premultiplied_alpha = (config->surface_caps & DSCAPS_PREMULTIPLIED)?1:0;
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: premultiplied alpha = %lu\n", (unsigned long) tmp.premultiplied_alpha);
+  }
+
+  if((updated & CLRCF_OPACITY) &&
+     (shd->originalVarCaps & STMFBIO_VAR_CAPS_OPACITY))
+  {
+    tmp.caps   |= STMFBIO_VAR_CAPS_OPACITY;
+    tmp.opacity = (config->options & DLOP_OPACITY)?config->opacity:255;
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: opacity = %lu\n", (unsigned long)tmp.opacity);
+  }
+
+  if((updated & CLRCF_ALPHA_RAMP) &&
+     (shd->originalVarCaps & STMFBIO_VAR_CAPS_ALPHA_RAMP))
+  {
+    tmp.caps         |= STMFBIO_VAR_CAPS_ALPHA_RAMP;
+    tmp.alpha_ramp[0] = config->alpha_ramp[0];
+    tmp.alpha_ramp[1] = config->alpha_ramp[3];
+  }
+
+  if(tmp.caps != 0)
+  {
+    if(ioctl(drv->fd, STMFBIO_SET_VAR_SCREENINFO_EX, &tmp) < 0)
+      return DFB_IO;
+  }
+
+  return DFB_OK;
+}
+
+
+static DFBResult stgfxPrimaryGetLevel( CoreLayer              *layer,
+                                       void                   *driver_data,
+                                       void                   *layer_data,
+                                       int                    *level )
+{
+  STGFXDriverData                  *drv = (STGFXDriverData*) driver_data;
+  STGFXDriverSharedData            *shd = (STGFXDriverSharedData*) layer_data;
+  struct stmfbio_var_screeninfo_ex  tmp = {0};
+
+  if(!(shd->originalVarCaps & STMFBIO_VAR_CAPS_ZPOSITION))
+    return DFB_UNSUPPORTED;
+
+  tmp.layerid = dfb_layer_id_translated(layer);
+
+  if(ioctl(drv->fd, STMFBIO_GET_VAR_SCREENINFO_EX, &tmp) < 0)
+    return DFB_IO;
+
+  *level = (int)tmp.z_position;
+
+  return DFB_OK;
+}
+
+
+static DFBResult stgfxPrimarySetLevel( CoreLayer              *layer,
+                                       void                   *driver_data,
+                                       void                   *layer_data,
+                                       int                     level )
+{
+  STGFXDriverData                  *drv = (STGFXDriverData*) driver_data;
+  STGFXDriverSharedData            *shd = (STGFXDriverSharedData*) layer_data;
+  struct stmfbio_var_screeninfo_ex  tmp = {0};
+
+  if(!(shd->originalVarCaps & STMFBIO_VAR_CAPS_ZPOSITION))
+    return DFB_UNSUPPORTED;
+
+  tmp.layerid    = dfb_layer_id_translated(layer);
+  tmp.activate   = STMFBIO_ACTIVATE_IMMEDIATE;
+  tmp.caps       = STMFBIO_VAR_CAPS_ZPOSITION;
+  tmp.z_position = (level<0)?0:level;
+
+  if(ioctl(drv->fd, STMFBIO_SET_VAR_SCREENINFO_EX, &tmp) < 0)
+  {
+    if(errno == EINVAL)
+      return DFB_INVARG;
+    else
+      return DFB_IO;
+  }
+
+  return DFB_OK;
+}
+
+
+static DFBResult stgfxPrimarySetColorAdjustment( CoreLayer              *layer,
+                                                 void                   *driver_data,
+                                                 void                   *layer_data,
+                                                 DFBColorAdjustment     *adjustment )
+{
+  STGFXDriverData       *drv = (STGFXDriverData*) driver_data;
+  STGFXDriverSharedData *shd = (STGFXDriverSharedData*) layer_data;
+
+  struct stmfbio_var_screeninfo_ex tmp = {0};
+
+  tmp.layerid  = dfb_layer_id_translated(layer);
+  tmp.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+
+  if(adjustment->flags & DCAF_BRIGHTNESS)
+  {
+    if(shd->originalVarCaps & STMFBIO_VAR_CAPS_BRIGHTNESS)
+    {
+      tmp.caps |= STMFBIO_VAR_CAPS_BRIGHTNESS;
+      tmp.brightness = adjustment->brightness >> 8;
+    }
+    else
+    {
+      tmp.caps |= STMFBIO_VAR_CAPS_GAIN;
+      if(adjustment->brightness > 0x8000)
+        tmp.gain = 255;
+      else
+        tmp.gain = ((adjustment->brightness >> 8)*255)/128; /* 0-0x8000 -> 0-255 */
+    }
+  }
+
+  if(adjustment->flags & DCAF_CONTRAST)
+  {
+    tmp.caps |= STMFBIO_VAR_CAPS_CONTRAST;
+    tmp.contrast = adjustment->contrast >> 8;
+  }
+
+  if(adjustment->flags & DCAF_HUE)
+  {
+    tmp.caps |= STMFBIO_VAR_CAPS_TINT;
+    tmp.tint = adjustment->hue >> 8;
+  }
+
+  if(adjustment->flags & DCAF_SATURATION)
+  {
+    tmp.caps |= STMFBIO_VAR_CAPS_SATURATION;
+    tmp.saturation = adjustment->saturation >> 8;
+  }
+
+  if(ioctl(drv->fd, STMFBIO_SET_VAR_SCREENINFO_EX, &tmp) < 0)
+  {
+    if(errno == EINVAL)
+      return DFB_INVARG;
+    else
+      return DFB_IO;
+  }
+
+  return DFB_OK;
+}
+
+
+/* Returns size of shared area to create as Layer_Data */
+static int stgfxPrimaryLayerDataSize(void)
+{
+  return sizeof(STGFXDriverSharedData);
+}
+
+
+DisplayLayerFuncs stgfxPrimaryLayerFuncs = {
+  InitLayer:          stgfxPrimaryInitLayer,
+
+  TestRegion:         stgfxPrimaryTestRegion,
+  SetRegion:          stgfxPrimarySetRegion,
+
+  GetLevel:           stgfxPrimaryGetLevel,
+  SetLevel:           stgfxPrimarySetLevel,
+
+  LayerDataSize:      stgfxPrimaryLayerDataSize,
+
+  SetColorAdjustment: stgfxPrimarySetColorAdjustment
+};
This patch adds primary screen control to the ST driver. This requires
the new STMFBIO_{GET|SET}_OUTPUT_CONFIG IOCTL's in the STLinux open source
framebuffer driver.  It adds support for the selection of:

(o) analogue,HDMI and DVO (where available) signals;
(o) the HDMI colour space (RGB or YUV);
(o) the mixer background colour (where available);
(o) the DENC encoder standard and adjustment controls (brightness
    etc..) for SD TV output.

Signed off by: Stephen Gallimore <Stephen.Gallimore@st.com>
Index: DirectFB-1.0.1/gfxdrivers/stgfx/stgfx.c
===================================================================
--- DirectFB-1.0.1.orig/gfxdrivers/stgfx/stgfx.c	2007-09-24 15:17:08.123176645 +0100
+++ DirectFB-1.0.1/gfxdrivers/stgfx/stgfx.c	2007-09-24 15:17:25.368570949 +0100
@@ -44,6 +44,7 @@
 #include <core/system.h>
 #include <core/palette.h>
 #include <core/layers.h>
+#include <core/screens.h>
 
 #include <fbdev/fbdev.h>
 
@@ -1339,6 +1340,12 @@ static DFBResult driver_init_driver
    */
   pDrv->fd = -1;
 
+  if(dfb_system_type() != CORE_FBDEV)
+  {
+    D_ERROR("DirectFB/gfxdrivers/stgfx: Only supported on FBDev system");
+    return DFB_IO;
+  }
+
   FBDev *dfb_fbdev = (FBDev *)dfb_system_data();
 
   if(dfb_fbdev == NULL)
@@ -1383,8 +1390,13 @@ static DFBResult driver_init_driver
   dfb_layers_hook_primary( device, driver_data,
                                   &stgfxPrimaryLayerFuncs,
                                   &pDrv->primaryLayerFuncs,
-                                  &pDrv->primaryDriverData );
+                                  &pDrv->primaryLayerData );
+
 
+  dfb_screens_hook_primary( device, driver_data,
+                                   &stgfxPrimaryScreenFuncs,
+                                   &pDrv->primaryScreenFuncs,
+                                   &pDrv->primaryScreenData );
 
   return DFB_OK;
 }
@@ -1467,6 +1479,8 @@ static void driver_close_driver
      */
     pDrv->originalVar.activate = STMFBIO_ACTIVATE_IMMEDIATE;
     ioctl(pDrv->fd, STMFBIO_SET_VAR_SCREENINFO_EX, &pDrv->originalVar);
+    pDrv->originalOutputConfig.activate = STMFBIO_ACTIVATE_IMMEDIATE;
+    ioctl(pDrv->fd, STMFBIO_SET_OUTPUT_CONFIG, &pDrv->originalOutputConfig);
     pDrv->fd = -1;
   }
 
Index: DirectFB-1.0.1/gfxdrivers/stgfx/stgfx.h
===================================================================
--- DirectFB-1.0.1.orig/gfxdrivers/stgfx/stgfx.h	2007-09-24 15:17:08.139177936 +0100
+++ DirectFB-1.0.1/gfxdrivers/stgfx/stgfx.h	2007-09-24 15:17:25.368570949 +0100
@@ -21,15 +21,25 @@
 
 typedef struct {
   int                              fd;
-  void                            *primaryDriverData;
+  void                            *primaryLayerData;
   DisplayLayerFuncs                primaryLayerFuncs;
+  void                            *primaryScreenData;
+  ScreenFuncs                      primaryScreenFuncs;
+
   struct stmfbio_var_screeninfo_ex originalVar;
+  struct stmfbio_output_configuration originalOutputConfig;
+
 } STGFXDriverData;
 
 typedef struct {
   u32                              originalVarCaps;
   DFBDisplayLayerOptions           primaryLayerOptions;
   DFBColorAdjustmentFlags          primaryLayerAdjustments;
-} STGFXDriverSharedData;
+} STGFXPrimaryLayerSharedData;
+
+typedef struct {
+  u32 originalOutputCaps;
+} STGFXPrimaryScreenSharedData;
 
 DisplayLayerFuncs stgfxPrimaryLayerFuncs;
+ScreenFuncs stgfxPrimaryScreenFuncs;
Index: DirectFB-1.0.1/gfxdrivers/stgfx/stgfx_primary.c
===================================================================
--- DirectFB-1.0.1.orig/gfxdrivers/stgfx/stgfx_primary.c	2007-09-24 15:17:08.171180523 +0100
+++ DirectFB-1.0.1/gfxdrivers/stgfx/stgfx_primary.c	2007-09-24 15:26:24.850446986 +0100
@@ -40,6 +40,11 @@
 #include <directfb.h>
 
 #include <core/layers.h>
+#include <core/screens.h>
+#include <core/system.h>
+
+#include <fbdev/fbdev.h>
+
 #include <direct/debug.h>
 #include <misc/conf.h>
 #include <gfx/convert.h>
@@ -53,15 +58,15 @@ static DFBResult stgfxPrimaryInitLayer( 
                                         DFBDisplayLayerConfig      *config,
                                         DFBColorAdjustment         *adjustment )
 {
-  DFBResult              ret;
-  STGFXDriverData       *drv = (STGFXDriverData*) driver_data;
-  STGFXDriverSharedData *shd = (STGFXDriverSharedData*) layer_data;
+  DFBResult                    ret;
+  STGFXDriverData             *drv = (STGFXDriverData*) driver_data;
+  STGFXPrimaryLayerSharedData *shd = (STGFXPrimaryLayerSharedData*) layer_data;
 
   D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: init layer\n");
 
   /* call the original initialization function first */
   ret = drv->primaryLayerFuncs.InitLayer( layer,
-                                          drv->primaryDriverData,
+                                          drv->primaryLayerData,
                                           layer_data, description,
                                           config, adjustment );
   if (ret)
@@ -89,7 +94,7 @@ static DFBResult stgfxPrimaryInitLayer( 
   /* Duplicate originalVar.caps into Shared Memory for Fusion Slaves. */
   shd->originalVarCaps = drv->originalVar.caps;
 
-  D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: got extended var\n");
+  D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: got extended var caps = 0x%08x\n",(unsigned)shd->originalVarCaps);
 
   /* set name */
   snprintf(description->name,
@@ -138,7 +143,16 @@ static DFBResult stgfxPrimaryInitLayer( 
     description->caps        |= DLCAPS_OPACITY;
   }
 
+  /*
+   * Clear the adjustments added by the fbdev system, we can't support the
+   * gamma ramp approach, so override with the plane capabilities instead.
+   */
   adjustment->flags = 0;
+  shd->primaryLayerAdjustments = 0;
+  description->caps &= ~(DLCAPS_BRIGHTNESS |
+                         DLCAPS_CONTRAST   |
+                         DLCAPS_SATURATION |
+                         DLCAPS_HUE);
 
   if(drv->originalVar.caps & (STMFBIO_VAR_CAPS_GAIN | STMFBIO_VAR_CAPS_BRIGHTNESS))
   {
@@ -199,16 +213,16 @@ static DFBResult stgfxPrimaryTestRegion(
                                          CoreLayerRegionConfig      *config,
                                          CoreLayerRegionConfigFlags *failed )
 {
-   DFBResult                  ret;
-   CoreLayerRegionConfigFlags fail = 0;
-   DFBDisplayLayerOptions     options = config->options;
-   STGFXDriverData           *drv = (STGFXDriverData*) driver_data;
-   STGFXDriverSharedData     *shd = (STGFXDriverSharedData*) layer_data;
+   DFBResult                    ret;
+   CoreLayerRegionConfigFlags   fail = 0;
+   DFBDisplayLayerOptions       options = config->options;
+   STGFXDriverData             *drv = (STGFXDriverData*) driver_data;
+   STGFXPrimaryLayerSharedData *shd = (STGFXPrimaryLayerSharedData*) layer_data;
 
    /* remove options before calling the original function */
    config->options = DLOP_NONE;
 
-   ret = drv->primaryLayerFuncs.TestRegion( layer, drv->primaryDriverData,
+   ret = drv->primaryLayerFuncs.TestRegion( layer, drv->primaryLayerData,
                                             layer_data, config, &fail );
 
    /* restore options */
@@ -245,13 +259,13 @@ static DFBResult stgfxPrimarySetRegion( 
 {
   DFBResult                         ret;
   STGFXDriverData                  *drv = (STGFXDriverData*) driver_data;
-  STGFXDriverSharedData            *shd = (STGFXDriverSharedData*) layer_data;
+  STGFXPrimaryLayerSharedData      *shd = (STGFXPrimaryLayerSharedData*) layer_data;
   struct stmfbio_var_screeninfo_ex  tmp = {0};
 
   D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: set region layer = %p config = %p surface = %p\n",layer,config,surface);
 
   /* call the original function */
-  ret = drv->primaryLayerFuncs.SetRegion( layer, drv->primaryDriverData,
+  ret = drv->primaryLayerFuncs.SetRegion( layer, drv->primaryLayerData,
                                           layer_data, region_data,
                                           config, updated, surface,
                                           palette );
@@ -322,7 +336,7 @@ static DFBResult stgfxPrimaryGetLevel( C
                                        int                    *level )
 {
   STGFXDriverData                  *drv = (STGFXDriverData*) driver_data;
-  STGFXDriverSharedData            *shd = (STGFXDriverSharedData*) layer_data;
+  STGFXPrimaryLayerSharedData      *shd = (STGFXPrimaryLayerSharedData*) layer_data;
   struct stmfbio_var_screeninfo_ex  tmp = {0};
 
   if(!(shd->originalVarCaps & STMFBIO_VAR_CAPS_ZPOSITION))
@@ -345,7 +359,7 @@ static DFBResult stgfxPrimarySetLevel( C
                                        int                     level )
 {
   STGFXDriverData                  *drv = (STGFXDriverData*) driver_data;
-  STGFXDriverSharedData            *shd = (STGFXDriverSharedData*) layer_data;
+  STGFXPrimaryLayerSharedData      *shd = (STGFXPrimaryLayerSharedData*) layer_data;
   struct stmfbio_var_screeninfo_ex  tmp = {0};
 
   if(!(shd->originalVarCaps & STMFBIO_VAR_CAPS_ZPOSITION))
@@ -373,8 +387,8 @@ static DFBResult stgfxPrimarySetColorAdj
                                                  void                   *layer_data,
                                                  DFBColorAdjustment     *adjustment )
 {
-  STGFXDriverData       *drv = (STGFXDriverData*) driver_data;
-  STGFXDriverSharedData *shd = (STGFXDriverSharedData*) layer_data;
+  STGFXDriverData             *drv = (STGFXDriverData*) driver_data;
+  STGFXPrimaryLayerSharedData *shd = (STGFXPrimaryLayerSharedData*) layer_data;
 
   struct stmfbio_var_screeninfo_ex tmp = {0};
 
@@ -431,7 +445,7 @@ static DFBResult stgfxPrimarySetColorAdj
 /* Returns size of shared area to create as Layer_Data */
 static int stgfxPrimaryLayerDataSize(void)
 {
-  return sizeof(STGFXDriverSharedData);
+  return sizeof(STGFXPrimaryLayerSharedData);
 }
 
 
@@ -448,3 +462,763 @@ DisplayLayerFuncs stgfxPrimaryLayerFuncs
 
   SetColorAdjustment: stgfxPrimarySetColorAdjustment
 };
+
+
+/******************************************************************************/
+
+static int stgfxPrimaryScreenDataSize(void)
+{
+  return sizeof(STGFXPrimaryScreenSharedData);
+}
+
+
+static DFBResult stgfxPrimaryInitScreen( CoreScreen                   *screen,
+                                         GraphicsDevice               *device,
+                                         void                         *driver_data,
+                                         void                         *screen_data,
+                                         DFBScreenDescription         *description )
+{
+  DFBResult ret;
+  STGFXDriverData *drv = (STGFXDriverData*) driver_data;
+  STGFXPrimaryScreenSharedData *shd = (STGFXPrimaryScreenSharedData*) screen_data;
+  FBDev *dfb_fbdev = (FBDev *)dfb_system_data();
+
+  ret = drv->primaryScreenFuncs.InitScreen(screen, drv->primaryScreenData,
+                                           driver_data,screen_data,description);
+  if(ret != DFB_OK)
+    return ret;
+
+  /*
+   * As we are talking to TVs these is no VESA power management control of the
+   * display implemented.
+   */
+  description->caps &= ~DSCCAPS_POWER_MANAGEMENT;
+
+  snprintf( description->name,
+            DFB_SCREEN_DESC_NAME_LENGTH, dfb_fbdev->shared->fix.id );
+
+  memset(&drv->originalOutputConfig,0,sizeof(struct stmfbio_output_configuration));
+  drv->originalOutputConfig.outputid = 1;
+
+  if(ioctl(drv->fd, STMFBIO_GET_OUTPUT_CONFIG, &drv->originalOutputConfig) < 0)
+  {
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: init screen, get output config failed!\n");
+    return DFB_IO;
+  }
+
+  shd->originalOutputCaps = drv->originalOutputConfig.caps;
+
+  if(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_MIXER_BACKGROUND)
+  {
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: init screen, have mixer background\n");
+    description->caps |= DSCCAPS_MIXERS;
+    description->mixers = 1;
+  }
+
+  if(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_SDTV_ENCODING)
+  {
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: init screen, have denc\n");
+    description->caps |= DSCCAPS_ENCODERS;
+    description->encoders = 1;
+  }
+
+  description->caps |= DSCCAPS_OUTPUTS;
+  description->outputs = 3;
+
+  return DFB_OK;
+}
+
+
+static DFBResult stgfxPrimaryInitMixer( CoreScreen                   *screen,
+                                        void                         *driver_data,
+                                        void                         *screen_data,
+                                        int                           mixer,
+                                        DFBScreenMixerDescription    *description,
+                                        DFBScreenMixerConfig         *config )
+{
+  STGFXDriverData *drv = (STGFXDriverData*) driver_data;
+
+  description->caps = DSMCAPS_FULL | DSMCAPS_BACKGROUND;
+
+  DFB_DISPLAYLAYER_IDS_ADD(description->layers,DLID_PRIMARY);
+
+  snprintf( description->name,
+            DFB_SCREEN_MIXER_DESC_NAME_LENGTH, "STM Mixer" );
+
+  config->flags = DSMCONF_TREE | DSMCONF_BACKGROUND;
+  config->tree = DSMT_FULL;
+  config->background.a = (drv->originalOutputConfig.mixer_background>>24) & 0xff;
+  config->background.r = (drv->originalOutputConfig.mixer_background>>16) & 0xff;
+  config->background.g = (drv->originalOutputConfig.mixer_background>>8)  & 0xff;
+  config->background.b = drv->originalOutputConfig.mixer_background       & 0xff;
+
+  D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: init mixer, background colour = 0x%08x\n",drv->originalOutputConfig.mixer_background);
+
+  return DFB_OK;
+}
+
+
+static DFBScreenEncoderTVStandards stgfxConvertTVStandard(__u32 sdtv_encoding)
+{
+  switch(sdtv_encoding)
+  {
+    case STMFBIO_OUTPUT_STD_PAL_BDGHI:
+      return DSETV_PAL;
+
+    case STMFBIO_OUTPUT_STD_PAL_M:
+      return DSETV_PAL_M;
+
+    case STMFBIO_OUTPUT_STD_PAL_N:
+      return DSETV_PAL_N;
+
+    case STMFBIO_OUTPUT_STD_PAL_Nc:
+      return DSETV_PAL_NC;
+
+    case STMFBIO_OUTPUT_STD_NTSC_M:
+      return DSETV_NTSC;
+
+    case STMFBIO_OUTPUT_STD_NTSC_J:
+      return DSETV_NTSC_M_JPN;
+
+    case STMFBIO_OUTPUT_STD_NTSC_443:
+      return DSETV_NTSC_443;
+
+    case STMFBIO_OUTPUT_STD_SECAM:
+      return DSETV_SECAM;
+
+    case STMFBIO_OUTPUT_STD_PAL_60:
+      return DSETV_PAL_60;
+
+    default:
+      D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: init encoder, invalid encoding from kernel = %u\n",sdtv_encoding);
+      return DSETV_UNKNOWN;
+  }
+}
+
+
+static DFBResult stgfxPrimaryInitEncoder( CoreScreen                   *screen,
+                                          void                         *driver_data,
+                                          void                         *screen_data,
+                                          int                           encoder,
+                                          DFBScreenEncoderDescription  *description,
+                                          DFBScreenEncoderConfig       *config )
+{
+  STGFXDriverData *drv = (STGFXDriverData*) driver_data;
+  STGFXPrimaryScreenSharedData *shd = (STGFXPrimaryScreenSharedData*) screen_data;
+
+  description->caps = DSECAPS_TV_STANDARDS;
+  description->type = DSET_TV;
+  description->tv_standards = (DSETV_PAL | DSETV_NTSC | DSETV_SECAM |
+                              DSETV_PAL_60 | DSETV_PAL_BG | DSETV_PAL_I |
+                              DSETV_PAL_M  | DSETV_PAL_N | DSETV_PAL_NC |
+                              DSETV_NTSC_M_JPN | DSETV_NTSC_443);
+
+  snprintf( description->name,
+            DFB_SCREEN_ENCODER_DESC_NAME_LENGTH, "STM DENC" );
+
+  config->flags = DSECONF_NONE;
+  config->tv_standard = stgfxConvertTVStandard(drv->originalOutputConfig.sdtv_encoding);
+
+  if(config->tv_standard == DSETV_UNKNOWN)
+    return DFB_IO;
+
+
+  D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: init encoder, tv encoding = %u\n",(unsigned)config->tv_standard);
+
+  config->flags |= (DSECONF_TV_STANDARD | DSECONF_SCANMODE);
+  config->scanmode = DSESM_INTERLACED;
+
+  if(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_BRIGHTNESS)
+  {
+    description->caps |= DSECAPS_BRIGHTNESS;
+    config->flags |= DSECONF_ADJUSTMENT;
+    config->adjustment.flags |= DCAF_BRIGHTNESS;
+    config->adjustment.brightness = ((u16)drv->originalOutputConfig.brightness)<<8;
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: init encoder, brightness = %u\n",(unsigned)config->adjustment.brightness);
+  }
+
+  if(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_CONTRAST)
+  {
+    description->caps |= DSECAPS_CONTRAST;
+    config->flags |= DSECONF_ADJUSTMENT;
+    config->adjustment.flags |= DCAF_CONTRAST;
+    config->adjustment.contrast = ((u16)drv->originalOutputConfig.contrast)<<8;
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: init encoder, contrast = %u\n",(unsigned)config->adjustment.contrast);
+  }
+
+  if(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_SATURATION)
+  {
+    description->caps |= DSECAPS_SATURATION;
+    config->flags |= DSECONF_ADJUSTMENT;
+    config->adjustment.flags |= DCAF_SATURATION;
+    config->adjustment.saturation = ((u16)drv->originalOutputConfig.saturation)<<8;
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: init encoder, saturation = %u\n",(unsigned)config->adjustment.saturation);
+  }
+
+  if(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_HUE)
+  {
+    description->caps |= DSECAPS_HUE;
+    config->flags |= DSECONF_ADJUSTMENT;
+    config->adjustment.flags |= DCAF_HUE;
+    config->adjustment.hue = ((u16)drv->originalOutputConfig.hue)<<8;
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: init encoder, hue = %u\n",(unsigned)config->adjustment.hue);
+  }
+
+  return DFB_OK;
+}
+
+
+static DFBResult stgfxPrimaryInitOutput( CoreScreen                   *screen,
+                                         void                         *driver_data,
+                                         void                         *screen_data,
+                                         int                           output,
+                                         DFBScreenOutputDescription   *description,
+                                         DFBScreenOutputConfig        *config )
+{
+  STGFXDriverData *drv = (STGFXDriverData*) driver_data;
+  STGFXPrimaryScreenSharedData *shd = (STGFXPrimaryScreenSharedData*) screen_data;
+
+  switch(output)
+  {
+    case 0:
+    {
+      if(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_ANALOGUE_CONFIG)
+      {
+        description->caps = DSOCAPS_SIGNAL_SEL;
+        description->all_signals = DSOS_RGB | DSOS_YCBCR;
+        if(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_SDTV_ENCODING)
+          description->all_signals |= DSOS_CVBS | DSOS_YC;
+
+        snprintf( description->name,
+                  DFB_SCREEN_OUTPUT_DESC_NAME_LENGTH, "STM Analogue Output" );
+
+        config->flags = DSOCONF_SIGNALS;
+        config->out_signals = 0;
+        if(drv->originalOutputConfig.analogue_config & STMFBIO_OUTPUT_ANALOGUE_RGB)
+          config->out_signals |= DSOS_RGB;
+
+        if(drv->originalOutputConfig.analogue_config & STMFBIO_OUTPUT_ANALOGUE_YPrPb)
+          config->out_signals |= DSOS_YCBCR;
+
+        if(drv->originalOutputConfig.analogue_config & STMFBIO_OUTPUT_ANALOGUE_YC)
+          config->out_signals |= DSOS_YC;
+
+        if(drv->originalOutputConfig.analogue_config & STMFBIO_OUTPUT_ANALOGUE_CVBS)
+          config->out_signals |= DSOS_CVBS;
+
+      }
+      break;
+    }
+    case 1:
+    {
+      if(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_HDMI_CONFIG)
+      {
+        description->caps = DSOCAPS_SIGNAL_SEL;
+        description->all_signals = DSOS_HDMI | DSOS_RGB | DSOS_YCBCR;
+
+        snprintf( description->name,
+                  DFB_SCREEN_OUTPUT_DESC_NAME_LENGTH, "STM HDMI Output" );
+
+        config->flags = DSOCONF_SIGNALS;
+        if(drv->originalOutputConfig.hdmi_config & STMFBIO_OUTPUT_HDMI_DISABLED)
+        {
+          config->out_signals = DSOS_NONE;
+        }
+        else
+        {
+          config->out_signals = DSOS_HDMI;
+          /*
+           * A bit of bending the interface to specify the HDMI colourspace
+           */
+          if(drv->originalOutputConfig.hdmi_config & STMFBIO_OUTPUT_HDMI_YUV)
+            config->out_signals |= DSOS_YCBCR;
+          else
+            config->out_signals |= DSOS_RGB;
+        }
+      }
+      break;
+    }
+    case 2:
+    {
+      if(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_DVO_CONFIG)
+      {
+        description->caps = DSOCAPS_SIGNAL_SEL;
+        description->all_signals = DSOS_656;
+
+        snprintf( description->name,
+                  DFB_SCREEN_OUTPUT_DESC_NAME_LENGTH, "STM DVO Output" );
+
+        config->flags = DSOCONF_SIGNALS;
+        if(drv->originalOutputConfig.dvo_config & STMFBIO_OUTPUT_DVO_DISABLED)
+          config->out_signals = DSOS_NONE;
+        else
+          config->out_signals = DSOS_656;
+      }
+      break;
+    }
+    default:
+      return DFB_INVARG;
+  }
+  return DFB_OK;
+}
+
+/** Mixer configuration **/
+
+static DFBResult stgfxPrimaryDoMixerConfig( CoreScreen                  *screen,
+                                            void                        *driver_data,
+                                            void                        *screen_data,
+                                            int                          mixer,
+                                            const DFBScreenMixerConfig  *config,
+                                            DFBScreenMixerConfigFlags   *failed,
+                                            bool                         test)
+{
+  STGFXDriverData *drv = (STGFXDriverData*) driver_data;
+  STGFXPrimaryScreenSharedData *shd = (STGFXPrimaryScreenSharedData*) screen_data;
+  struct stmfbio_output_configuration cfg = {0};
+
+  *failed = 0;
+  if((config->flags & DSMCONF_BACKGROUND) &&
+     !(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_MIXER_BACKGROUND))
+  {
+    *failed = DSMCONF_BACKGROUND;
+  }
+
+  if(config->flags & DSMCONF_TREE && config->tree != DSMT_FULL)
+  {
+    *failed |= DSMT_FULL;
+  }
+
+  if(config->flags & ~(DSMCONF_TREE | DSMCONF_BACKGROUND))
+  {
+    *failed |= config->flags & ~(DSMCONF_TREE | DSMCONF_BACKGROUND);
+  }
+
+  if(*failed != 0)
+    return DFB_INVARG;
+
+  cfg.outputid = 1;
+  cfg.caps     = STMFBIO_OUTPUT_CAPS_MIXER_BACKGROUND;
+  cfg.activate = test?STMFBIO_ACTIVATE_TEST:STMFBIO_ACTIVATE_IMMEDIATE;
+  cfg.mixer_background = ((config->background.a<<24) |
+                          (config->background.r<<16) |
+                          (config->background.g<<8)  |
+                           config->background.b);
+
+  if(ioctl(drv->fd, STMFBIO_SET_OUTPUT_CONFIG, &cfg) < 0)
+  {
+    *failed = config->flags;
+    if(cfg.failed != 0)
+      return DFB_INVARG;
+    else
+      return DFB_IO;
+  }
+
+  return DFB_OK;
+}
+
+
+static DFBResult stgfxPrimaryTestMixerConfig( CoreScreen                  *screen,
+                                              void                        *driver_data,
+                                              void                        *screen_data,
+                                              int                          mixer,
+                                              const DFBScreenMixerConfig  *config,
+                                              DFBScreenMixerConfigFlags   *failed )
+{
+  return stgfxPrimaryDoMixerConfig(screen,driver_data,screen_data,mixer,config,failed,true);
+}
+
+
+static DFBResult stgfxPrimarySetMixerConfig( CoreScreen                  *screen,
+                                             void                        *driver_data,
+                                             void                        *screen_data,
+                                             int                          mixer,
+                                             const DFBScreenMixerConfig  *config )
+{
+  DFBScreenMixerConfigFlags dummy;
+  return stgfxPrimaryDoMixerConfig(screen,driver_data,screen_data,mixer,config,&dummy,false);
+}
+
+
+/** Encoder configuration **/
+
+static DFBResult stgfxPrimaryDoEncoderConfig( CoreScreen                   *screen,
+                                              void                         *driver_data,
+                                              void                         *screen_data,
+                                              int                           encoder,
+                                              DFBScreenEncoderConfig       *config,
+                                              DFBScreenEncoderConfigFlags  *failed,
+                                              bool                          test)
+{
+  STGFXDriverData *drv = (STGFXDriverData*) driver_data;
+  struct stmfbio_output_configuration cfg = {0};
+
+  D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: %s\n", __FUNCTION__);
+
+  cfg.outputid = 1;
+  cfg.activate = test?STMFBIO_ACTIVATE_TEST:STMFBIO_ACTIVATE_IMMEDIATE;
+
+  *failed = config->flags & ~(DSECONF_SCANMODE | DSECONF_TV_STANDARD | DSECONF_ADJUSTMENT);
+
+  if((config->flags & DSECONF_SCANMODE) && (config->scanmode != DSESM_INTERLACED) )
+  {
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: encoder scanmode must be interlaced\n");
+    *failed |= DSECONF_SCANMODE;
+  }
+
+  if(*failed)
+  {
+    D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: encoder config failed = 0x%08x\n",(unsigned)*failed);
+    return DFB_INVARG;
+  }
+
+  if(config->flags & DSECONF_TV_STANDARD)
+  {
+    cfg.caps |= STMFBIO_OUTPUT_CAPS_SDTV_ENCODING;
+    switch(config->tv_standard)
+    {
+      case DSETV_PAL:
+        cfg.sdtv_encoding = STMFBIO_OUTPUT_STD_PAL_BDGHI;
+        break;
+      case DSETV_PAL_M:
+        cfg.sdtv_encoding = STMFBIO_OUTPUT_STD_PAL_M;
+        break;
+      case DSETV_PAL_N:
+        cfg.sdtv_encoding = STMFBIO_OUTPUT_STD_PAL_N;
+        break;
+      case DSETV_PAL_NC:
+        cfg.sdtv_encoding = STMFBIO_OUTPUT_STD_PAL_Nc;
+        break;
+      case DSETV_NTSC:
+        cfg.sdtv_encoding = STMFBIO_OUTPUT_STD_NTSC_M;
+        break;
+      case DSETV_NTSC_M_JPN:
+        cfg.sdtv_encoding = STMFBIO_OUTPUT_STD_NTSC_J;
+        break;
+      case DSETV_NTSC_443:
+        cfg.sdtv_encoding = STMFBIO_OUTPUT_STD_NTSC_443;
+        break;
+      case DSETV_SECAM:
+        cfg.sdtv_encoding = STMFBIO_OUTPUT_STD_SECAM;
+        break;
+      case DSETV_PAL_60:
+        cfg.sdtv_encoding = STMFBIO_OUTPUT_STD_PAL_60;
+        break;
+      default:
+        D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: unknown tv encoding 0x%08x\n",(unsigned)config->tv_standard);
+        *failed |= DSECONF_TV_STANDARD;
+        return DFB_INVARG;
+        break;
+    }
+  }
+
+  if(config->flags & DSECONF_ADJUSTMENT)
+  {
+    if(config->adjustment.flags & DCAF_BRIGHTNESS)
+    {
+      cfg.caps |= STMFBIO_OUTPUT_CAPS_BRIGHTNESS;
+      cfg.brightness = config->adjustment.brightness >> 8;
+    }
+    if(config->adjustment.flags & DCAF_SATURATION)
+    {
+      cfg.caps |= STMFBIO_OUTPUT_CAPS_SATURATION;
+      cfg.saturation = config->adjustment.saturation >> 8;
+    }
+    if(config->adjustment.flags & DCAF_CONTRAST)
+    {
+      cfg.caps |= STMFBIO_OUTPUT_CAPS_CONTRAST;
+      cfg.contrast = config->adjustment.contrast >> 8;
+    }
+    if(config->adjustment.flags & DCAF_HUE)
+    {
+      cfg.caps |= STMFBIO_OUTPUT_CAPS_HUE;
+      cfg.hue = config->adjustment.hue >> 8;
+    }
+  }
+
+  if(ioctl(drv->fd, STMFBIO_SET_OUTPUT_CONFIG, &cfg) < 0)
+  {
+    if(cfg.failed != 0)
+    {
+      /*
+       * Only report failures on test. If this was a set then we read back
+       * the actual config and pass that back. This avoids unnecessary failures
+       * when trying to set a tv standard in a mode that doesn't support it.
+       * Unfortunately even just changing an adjustment control will also
+       * try and set the tv standard as well. This is where the DirectFB
+       * semantics don't exactly match the way the hardware works.
+       */
+      if(test)
+      {
+        D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: output config ioctl failed 0x%08x\n",cfg.failed);
+        if(cfg.failed & STMFBIO_OUTPUT_CAPS_SDTV_ENCODING)
+          *failed |= DSECONF_TV_STANDARD;
+
+        if(cfg.failed & STMFBIO_OUTPUT_CAPS_PSI_MASK)
+          *failed |= DSECONF_ADJUSTMENT;
+
+        return DFB_INVARG;
+      }
+    }
+    else
+    {
+      D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: ioctl IO error\n");
+      *failed = config->flags;
+      return DFB_IO;
+    }
+  }
+
+  if(!test)
+  {
+    struct stmfbio_output_configuration cfg = {1};
+    /*
+     * Read back configuration
+     */
+    if(ioctl(drv->fd, STMFBIO_GET_OUTPUT_CONFIG, &cfg) < 0)
+    {
+      D_DEBUG("DirectFB/gfxdrivers/stgfx_primary: do encoder, reading back output config failed!\n");
+      return DFB_IO;
+    }
+
+    if(cfg.caps & STMFBIO_OUTPUT_CAPS_SDTV_ENCODING)
+      config->tv_standard = stgfxConvertTVStandard(cfg.sdtv_encoding);
+
+    if(cfg.caps & STMFBIO_OUTPUT_CAPS_BRIGHTNESS)
+    {
+      config->adjustment.flags |= DCAF_BRIGHTNESS;
+      config->adjustment.brightness = (u16)cfg.brightness << 8;
+    }
+
+    if(cfg.caps & STMFBIO_OUTPUT_CAPS_SATURATION)
+    {
+      config->adjustment.flags |= DCAF_SATURATION;
+      config->adjustment.saturation = (u16)cfg.saturation << 8;
+    }
+
+    if(cfg.caps & STMFBIO_OUTPUT_CAPS_CONTRAST)
+    {
+      config->adjustment.flags |= DCAF_CONTRAST;
+      config->adjustment.contrast = (u16)cfg.contrast << 8;
+    }
+
+    if(cfg.caps & STMFBIO_OUTPUT_CAPS_HUE)
+    {
+      config->adjustment.flags |= DCAF_HUE;
+      config->adjustment.hue = (u16)cfg.hue << 8;
+    }
+  }
+
+  return DFB_OK;
+}
+
+
+static DFBResult stgfxPrimaryTestEncoderConfig( CoreScreen                   *screen,
+                                                void                         *driver_data,
+                                                void                         *screen_data,
+                                                int                           encoder,
+                                                const DFBScreenEncoderConfig *config,
+                                                DFBScreenEncoderConfigFlags  *failed )
+{
+  DFBScreenEncoderConfig tmp = *config;
+  return stgfxPrimaryDoEncoderConfig(screen,driver_data,screen_data,encoder,&tmp,failed,true);
+}
+
+
+static DFBResult stgfxPrimarySetEncoderConfig ( CoreScreen                   *screen,
+                                                void                         *driver_data,
+                                                void                         *screen_data,
+                                                int                           encoder,
+                                                const DFBScreenEncoderConfig *config )
+{
+  DFBScreenEncoderConfigFlags dummy;
+
+  return stgfxPrimaryDoEncoderConfig(screen,driver_data,screen_data,encoder,config,&dummy,false);
+}
+
+
+/** Output configuration **/
+
+static DFBResult stgfxPrimaryDoOutputConfig( CoreScreen                  *screen,
+                                             void                        *driver_data,
+                                             void                        *screen_data,
+                                             int                          output,
+                                             const DFBScreenOutputConfig *config,
+                                             DFBScreenOutputConfigFlags  *failed,
+                                             bool                         test)
+{
+  STGFXDriverData *drv = (STGFXDriverData*) driver_data;
+  STGFXPrimaryScreenSharedData *shd = (STGFXPrimaryScreenSharedData*) screen_data;
+  struct stmfbio_output_configuration cfg = {0};
+
+  cfg.outputid = 1;
+  cfg.activate = test?STMFBIO_ACTIVATE_TEST:STMFBIO_ACTIVATE_IMMEDIATE;
+
+  *failed = config->flags & ~DSOCONF_SIGNALS;
+  if(*failed)
+    return DFB_INVARG;
+
+  switch(output)
+  {
+    case 0:
+    {
+      if(config->out_signals & ~(DSOS_RGB | DSOS_YCBCR | DSOS_CVBS | DSOS_YC))
+        *failed = config->flags;
+
+      if(!(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_ANALOGUE_CONFIG))
+      {
+        if(config->out_signals == DSOS_NONE)
+        {
+          return DFB_OK;
+        }
+        else
+        {
+          *failed = config->flags;
+          return DFB_INVARG;
+        }
+      }
+      else
+      {
+        cfg.caps = STMFBIO_OUTPUT_CAPS_ANALOGUE_CONFIG;
+
+        if(config->out_signals & DSOS_RGB)
+          cfg.analogue_config |= STMFBIO_OUTPUT_ANALOGUE_RGB;
+
+        if(config->out_signals & DSOS_YCBCR)
+          cfg.analogue_config |= STMFBIO_OUTPUT_ANALOGUE_YPrPb;
+
+        if(config->out_signals & DSOS_CVBS)
+          cfg.analogue_config |= STMFBIO_OUTPUT_ANALOGUE_CVBS;
+
+        if(config->out_signals & DSOS_YC)
+          cfg.analogue_config |= STMFBIO_OUTPUT_ANALOGUE_YC;
+      }
+      break;
+    }
+    case 1:
+    {
+      if(config->out_signals & ~(DSOS_HDMI | DSOS_RGB | DSOS_YCBCR))
+        *failed = config->flags;
+
+      if((config->out_signals & (DSOS_RGB | DSOS_YCBCR)) == (DSOS_RGB | DSOS_YCBCR))
+        *failed = config->flags;
+
+      if(!(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_HDMI_CONFIG))
+      {
+        if(config->out_signals == DSOS_NONE)
+        {
+          return DFB_OK;
+        }
+        else
+        {
+          *failed = config->flags;
+          return DFB_INVARG;
+        }
+      }
+      else
+      {
+        cfg.caps = STMFBIO_OUTPUT_CAPS_HDMI_CONFIG;
+
+        if(config->out_signals & DSOS_HDMI)
+        {
+          cfg.hdmi_config = STMFBIO_OUTPUT_HDMI_ENABLED;
+          /*
+           * HDMI colourspace is RGB by default, only change it when YCBCR
+           * is specified.
+           */
+          if(config->out_signals & DSOS_YCBCR)
+            cfg.hdmi_config |= STMFBIO_OUTPUT_HDMI_YUV;
+        }
+        else
+        {
+          cfg.hdmi_config = STMFBIO_OUTPUT_HDMI_DISABLED;
+        }
+      }
+      break;
+    }
+    case 2:
+    {
+      if(config->out_signals & ~DSOS_656)
+        *failed = config->flags;
+
+      if(!(shd->originalOutputCaps & STMFBIO_OUTPUT_CAPS_DVO_CONFIG))
+      {
+        if(config->out_signals == DSOS_NONE)
+        {
+          return DFB_OK;
+        }
+        else
+        {
+          *failed = config->flags;
+          return DFB_INVARG;
+        }
+      }
+      else
+      {
+        cfg.caps = STMFBIO_OUTPUT_CAPS_DVO_CONFIG;
+
+        if(config->out_signals == DSOS_656)
+          cfg.dvo_config = STMFBIO_OUTPUT_DVO_ENABLED;
+        else
+          cfg.dvo_config = STMFBIO_OUTPUT_DVO_DISABLED;
+      }
+      break;
+    }
+    default:
+    {
+      *failed = config->flags;
+      return DFB_INVARG;
+    }
+  }
+
+  if(*failed)
+    return DFB_INVARG;
+
+  if(ioctl(drv->fd, STMFBIO_SET_OUTPUT_CONFIG, &cfg) < 0)
+  {
+    *failed = config->flags;
+    if(cfg.failed != 0)
+      return DFB_INVARG;
+    else
+      return DFB_IO;
+  }
+
+  return DFB_OK;
+}
+
+
+static DFBResult stgfxPrimaryTestOutputConfig( CoreScreen                  *screen,
+                                               void                        *driver_data,
+                                               void                        *screen_data,
+                                               int                          output,
+                                               const DFBScreenOutputConfig *config,
+                                               DFBScreenOutputConfigFlags  *failed )
+{
+  return stgfxPrimaryDoOutputConfig(screen,driver_data,screen_data,output,config,failed,true);
+}
+
+
+static DFBResult stgfxPrimarySetOutputConfig ( CoreScreen                  *screen,
+                                               void                        *driver_data,
+                                               void                        *screen_data,
+                                               int                          output,
+                                               const DFBScreenOutputConfig *config )
+{
+  DFBScreenOutputConfigFlags dummy;
+
+  return stgfxPrimaryDoOutputConfig(screen,driver_data,screen_data,output,config,&dummy,false);
+}
+
+
+ScreenFuncs stgfxPrimaryScreenFuncs = {
+  ScreenDataSize:     stgfxPrimaryScreenDataSize,
+  InitScreen:         stgfxPrimaryInitScreen,
+  InitMixer:          stgfxPrimaryInitMixer,
+  InitEncoder:        stgfxPrimaryInitEncoder,
+  InitOutput:         stgfxPrimaryInitOutput,
+
+  TestMixerConfig:    stgfxPrimaryTestMixerConfig,
+  SetMixerConfig:     stgfxPrimarySetMixerConfig,
+  TestEncoderConfig:  stgfxPrimaryTestEncoderConfig,
+  SetEncoderConfig:   stgfxPrimarySetEncoderConfig,
+  TestOutputConfig:   stgfxPrimaryTestOutputConfig,
+  SetOutputConfig:    stgfxPrimarySetOutputConfig
+};
New kernel headers don't export PAGE_SIZE, so slightly modify the test.

Signed-off-by: Stuart Menefy <stuart.menefy@st.com>

--- DirectFB-1.0.1.orig/lib/direct/system.c	2007-08-07 20:43:00.000000000 +0100
+++ DirectFB-1.0.1/lib/direct/system.c	2007-09-27 17:06:25.000000000 +0100
@@ -36,7 +36,8 @@
 
 #if HAVE_ASM_PAGE_H
 #include <asm/page.h>
-#else
+#endif
+#ifndef PAGE_SIZE
 #define PAGE_SIZE   sysconf( _SC_PAGESIZE )
 #endif
 
